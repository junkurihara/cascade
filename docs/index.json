[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/cascade.js",
    "content": "/**\n * cascade.js\n */\n\nimport {OpenPGP} from './suite_openpgp.js';\nimport {Jscu} from './suite_jscu.js';\nimport {generateKeyObject, importKeys, Keys} from './keys.js';\nimport {Signature} from './signature.js';\nimport {CascadedData, createCascadedData} from './cascaded_data.js';\nimport * as core from './core.js';\nimport cloneDeep from 'lodash.clonedeep';//'lodash/cloneDeep';\n\n\nexport async function createEncryptionCascade({keys, procedure}){\n  const localKeys = cloneDeep(keys);\n  const localProcedure = procedure.map( (x) => cloneDeep(x));\n\n  const cascade = new Cascade();\n  cascade._init({mode: 'encrypt', keys: localKeys, procedure: localProcedure});\n  await cascade._initEncryptionProcedure();\n\n  return cascade;\n}\n\nexport function createDecryptionCascade({keys, encrypted}){\n  const localKeys = cloneDeep(keys);\n\n  const cascade = new Cascade();\n  cascade._init({mode: 'decrypt', keys: localKeys, encrypted});\n  cascade._initDecryptionProcedure();\n\n  return cascade;\n}\n\n////////////////////\nconst modes = ['encrypt', 'decrypt'];\nclass Cascade extends Array {\n  _init({mode, keys, procedure, encrypted}){\n    // assertions\n    if (modes.indexOf(mode) < 0) throw new Error('InvalidMode');\n    if (!(keys instanceof Keys)) throw new Error('NotKeyObject');\n    if (keys.mode.indexOf(mode) < 0) throw new Error('UnmatchedKeyMode');\n\n    this._cascadeMode = mode;\n    this._orgKeys = keys;\n\n    if (mode === 'encrypt') {\n      if (!(procedure instanceof Array)) throw new Error('NotArrayProcedure');\n      const initial = procedure.map( (config) => {\n        if(typeof config.encrypt === 'undefined') throw new Error('InvalidProcedure');\n        return {config};\n      });\n      this.push(...initial);\n    }\n\n    if (mode === 'decrypt') {\n      if (!(encrypted instanceof CascadedData)) throw new Error('NotCascadedEncryptedData');\n      const initial = encrypted.map( (encryptedObject) => {\n        if(typeof encryptedObject.message === 'undefined') throw new Error('InvalidEncryptedMessage');\n        return {data: encryptedObject};\n      });\n      this.push(...initial);\n    }\n\n    // set original key to the final step in the procedure\n    this[this.length - 1].keys = this._orgKeys;\n  }\n\n  async _initEncryptionProcedure(){\n    // export signingKey for precedence\n    const signingKeys = this._orgKeys.keys.privateKeys;\n\n    const precedence = this.slice(0, this.length -1);\n    await Promise.all(precedence.map( async (proc, idx) => {\n      if (typeof proc.config.encrypt.onetimeKey === 'undefined') throw new Error('NoKeyParamsGiven');\n\n      const suiteObject = {encrypt_decrypt: proc.config.encrypt.suite};\n      const modeArray = ['encrypt'];\n\n      // key generation for encryption at this step\n      const keyParams = Object.assign({ suite: proc.config.encrypt.suite}, proc.config.encrypt.onetimeKey);\n      delete proc.config.encrypt.onetimeKey;\n      const onetimeKey = await generateKeyObject(keyParams); // generate keys\n      const onetimeKeyObject = (keyParams.keyParams.type === 'session')\n        ? {sessionKey: onetimeKey.key}\n        : {publicKeys: [onetimeKey.publicKey]};\n\n      // message for encryption at next step.\n      // [NOTE] message for the first step is directly given message to be encrypted, otherwise, previous private/session keys;\n      let nextStepMessage;\n      if (keyParams.keyParams.type === 'session') nextStepMessage = onetimeKey.key;\n      else {\n        if (keyParams.suite === 'jscu') nextStepMessage = await onetimeKey.privateKey.export('der');\n        else if (keyParams.suite === 'openpgp') nextStepMessage = onetimeKey.privateKey.toPacketlist().write();\n        else throw new Error('UnknownSuite');\n      }\n      this[idx+1].message = nextStepMessage;\n\n      // updated config and key object for signing and key import\n      if (typeof proc.config.sign !== 'undefined' && proc.config.sign.required){\n        proc.config.sign = Object.assign(proc.config.sign, this[this.length-1].config.sign);\n        onetimeKeyObject.privateKeys = signingKeys;\n        suiteObject.sign_verify = proc.config.sign.suite;\n        modeArray.push('sign');\n      }\n\n      this[idx].keys = await importKeys('object', {keys:onetimeKeyObject, suite: suiteObject, mode: modeArray});\n    }));\n  }\n\n  _initDecryptionProcedure(){\n    // do nothing at this point\n  }\n\n  async encrypt(message){\n    if(this._cascadeMode !== 'encrypt') throw new Error('NotEncryptionCascade');\n    if(!(message instanceof Uint8Array)) throw new Error('NotUint8ArrayMessage');\n\n    // set given message as the first step message\n    this[0].message = message;\n\n    const data = await Promise.all(this.map( (proc) => core.encrypt(proc)));\n    return createCascadedData(data);\n  }\n\n  async decrypt(){\n    if(this._cascadeMode !== 'decrypt') throw new Error('NotDecryptionCascade');\n\n    // export verificationKey for precedence\n    const verificationKeys = this._orgKeys.keys.publicKeys;\n\n    // serialized decryption\n    const decrypted = new Array(this.length);\n    for(let idx = this.length-1; idx >= 0; idx--) {\n      if (!(this[idx].keys instanceof Keys)) throw new Error('InvalidKeysObject');\n      if (typeof this[idx].data === 'undefined') throw new Error('InvalidDataObject');\n\n      decrypted[idx] = await core.decrypt(this[idx]);\n\n      // assign decrypted message as previous step decryption key\n      if(idx > 0){\n        const suiteObject = {encrypt_decrypt: this[idx-1].data.message.suite};\n        const modeArray = ['decrypt'];\n\n        let nextDecryptionKeyObject;\n        if (this[idx-1].data.message.keyType === 'session_key_encrypt') nextDecryptionKeyObject = {sessionKey: decrypted[idx].data};\n        else {\n          if (this[idx-1].data.message.suite === 'jscu'){\n            nextDecryptionKeyObject = {privateKeys: [await Jscu.importKey('der', decrypted[idx].data)]};\n          }\n          else if (this[idx-1].data.message.suite === 'openpgp'){\n            nextDecryptionKeyObject = {privateKeys: [await OpenPGP.importKey('der', decrypted[idx].data)]};\n          }\n          else throw new Error('UnknownSuite');\n        }\n\n        // updated config and key object for signing and key import\n        if (this[idx-1].data.signature instanceof Signature && typeof verificationKeys !== 'undefined'){\n          nextDecryptionKeyObject.publicKeys = verificationKeys;\n          suiteObject.sign_verify = this[idx-1].data.signature.suite;\n          modeArray.push('verify');\n        }\n        // WA for embedded signature\n        else if (typeof this[idx-1].data.message !== 'undefined'\n          && this[idx-1].data.message.suite === 'openpgp'\n          && typeof verificationKeys !== 'undefined' ) {\n          nextDecryptionKeyObject.publicKeys = verificationKeys;\n          suiteObject.sign_verify = 'openpgp';\n          modeArray.push('verify');\n        }\n\n        this[idx-1].keys = await importKeys('object', { keys: nextDecryptionKeyObject, suite: suiteObject, mode: modeArray });\n      }\n    }\n    return decrypted;\n\n  }\n\n  get mode () { return this._cascadeMode; }\n  get keys () { return this._orgKeys; }\n  // get allKeys () { return null; } // TODO\n\n  toArray() { return Array.from(this); }\n\n  map(callback) { return this.toArray().map(callback); }\n  slice (a, b) { return this.toArray().slice(a, b); }\n}\n\n\n",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/cascade.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "function",
    "name": "createEncryptionCascade",
    "memberof": "src/cascade.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/cascade.js~createEncryptionCascade",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/cascade.js",
    "importStyle": "{createEncryptionCascade}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"keys\": *, \"procedure\": *}"
        ],
        "defaultRaw": {
          "keys": null,
          "procedure": null
        },
        "defaultValue": "{\"keys\":null,\"procedure\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "function",
    "name": "createDecryptionCascade",
    "memberof": "src/cascade.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cascade.js~createDecryptionCascade",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/cascade.js",
    "importStyle": "{createDecryptionCascade}",
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"keys\": *, \"encrypted\": *}"
        ],
        "defaultRaw": {
          "keys": null,
          "encrypted": null
        },
        "defaultValue": "{\"keys\":null,\"encrypted\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "variable",
    "name": "modes",
    "memberof": "src/cascade.js",
    "static": true,
    "longname": "src/cascade.js~modes",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/cascade.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 52,
    "kind": "class",
    "name": "Cascade",
    "memberof": "src/cascade.js",
    "static": true,
    "longname": "src/cascade.js~Cascade",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/cascade.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "interface": false,
    "extends": [
      "Array"
    ],
    "ignore": true
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "_init",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#_init",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "params": [
      {
        "name": "objectPattern",
        "types": [
          "{\"mode\": *, \"keys\": *, \"procedure\": *, \"encrypted\": *}"
        ],
        "defaultRaw": {
          "mode": null,
          "keys": null,
          "procedure": null,
          "encrypted": null
        },
        "defaultValue": "{\"mode\":null,\"keys\":null,\"procedure\":null,\"encrypted\":null}"
      }
    ],
    "return": null
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "_cascadeMode",
    "memberof": "src/cascade.js~Cascade",
    "static": false,
    "longname": "src/cascade.js~Cascade#_cascadeMode",
    "access": "private",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "_orgKeys",
    "memberof": "src/cascade.js~Cascade",
    "static": false,
    "longname": "src/cascade.js~Cascade#_orgKeys",
    "access": "private",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "method",
    "name": "_initEncryptionProcedure",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/cascade.js~Cascade#_initEncryptionProcedure",
    "access": "private",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 57,
    "kind": "method",
    "name": "_initDecryptionProcedure",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#_initDecryptionProcedure",
    "access": "private",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 58,
    "kind": "method",
    "name": "encrypt",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/cascade.js~Cascade#encrypt",
    "access": "public",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "method",
    "name": "decrypt",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/cascade.js~Cascade#decrypt",
    "access": "public",
    "description": null,
    "lineNumber": 126,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "get",
    "name": "mode",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#mode",
    "access": "public",
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "get",
    "name": "keys",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#keys",
    "access": "public",
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#toArray",
    "access": "public",
    "description": null,
    "lineNumber": 183,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "method",
    "name": "map",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#map",
    "access": "public",
    "description": null,
    "lineNumber": 185,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "method",
    "name": "slice",
    "memberof": "src/cascade.js~Cascade",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascade.js~Cascade#slice",
    "access": "public",
    "description": null,
    "lineNumber": 186,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "file",
    "name": "src/cascaded_data.js",
    "content": "/**\n * cascaded_data.js\n */\n\nimport msgpack from 'msgpack-lite';\nimport {importEncryptedBuffer, EncryptedMessage} from './encrypted_message.js';\nimport {importSignatureBuffer, Signature} from './signature.js';\n\nexport function importCascadedBuffer(serialized){\n  if (!(serialized instanceof Uint8Array)) throw new Error('NonUint8ArraySerializedData');\n  let des;\n  try {\n    des = msgpack.decode(serialized);\n  } catch (e) { throw new Error(`FailedToParseCascadedBuffer: ${e.message}`); }\n\n  if (!(des instanceof Array)) throw new Error('InvalidCascadedData');\n\n  const desComponentList = des.map( (obj) => {\n    const returnObject = {};\n    if(typeof obj.message !== 'undefined') returnObject.message = importEncryptedBuffer(obj.message);\n    if(typeof obj.signature !== 'undefined') returnObject.signature = importSignatureBuffer(obj.signature);\n    return returnObject;\n  });\n\n  return createCascadedData(desComponentList);\n}\n\nexport function createCascadedData(data) {\n  // assertion\n  if (!(data instanceof Array)) throw new Error('NotArrayForCascadedData');\n  data.map( (obj) => {\n    if(typeof obj.message !== 'undefined' && !(obj.message instanceof EncryptedMessage)) throw new Error('InvalidEncryptedMessage');\n    if(typeof obj.signature !== 'undefined' && !(obj.signature instanceof Signature)) throw new Error('InvalidSignature');\n    if(typeof obj.message === 'undefined' && typeof obj.signature === 'undefined') throw new Error('NoEncryptedMessageAndSignature');\n  });\n\n  return new CascadedData(data);\n}\n\nexport class CascadedData extends Array {\n  constructor(data){\n    super();\n    this.push(...data);\n  }\n\n  extract(idx) {\n    if (idx > this.length -1 || idx < 0) throw new Error('InvalidIndexOutOfRange');\n    if (typeof this[idx].message === 'undefined') throw new Error('MessageObjectDoesNotExist');\n\n    return this[idx].message.extract();\n  }\n\n  insert(idx, message) {\n    if (idx > this.length -1 || idx < 0) throw new Error('InvalidIndexOutOfRange');\n    if (!(message instanceof Array)) throw new Error('InvalidEncryptedMessageArray');\n    if (this[idx].message.length > 0) throw new Error('MessageAlreadyExists');\n\n    this[idx].message.insert(message);\n  }\n\n  serialize() {\n    const serializedCompArray = this.map( (obj) => {\n      const returnObject = {};\n      if (typeof obj.message !== 'undefined') returnObject.message = new Uint8Array(obj.message.serialize());\n      if (typeof obj.signature !== 'undefined') returnObject.signature = new Uint8Array(obj.signature.serialize());\n      return returnObject;\n    });\n    const returnArray = msgpack.encode(serializedCompArray);\n    return new Uint8Array(returnArray);\n  }\n\n  toArray() { return Array.from(this); }\n\n  map(callback) { return Array.from(this).map(callback); }\n}\n",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/cascaded_data.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 66,
    "kind": "function",
    "name": "importCascadedBuffer",
    "memberof": "src/cascaded_data.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cascaded_data.js~importCascadedBuffer",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/cascaded_data.js",
    "importStyle": "{importCascadedBuffer}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "params": [
      {
        "name": "serialized",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "function",
    "name": "createCascadedData",
    "memberof": "src/cascaded_data.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/cascaded_data.js~createCascadedData",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/cascaded_data.js",
    "importStyle": "{createCascadedData}",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "class",
    "name": "CascadedData",
    "memberof": "src/cascaded_data.js",
    "static": true,
    "longname": "src/cascaded_data.js~CascadedData",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/cascaded_data.js",
    "importStyle": "{CascadedData}",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "interface": false,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 69,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/cascaded_data.js~CascadedData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascaded_data.js~CascadedData#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 41,
    "undocument": true
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "extract",
    "memberof": "src/cascaded_data.js~CascadedData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascaded_data.js~CascadedData#extract",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "params": [
      {
        "name": "idx",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "insert",
    "memberof": "src/cascaded_data.js~CascadedData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascaded_data.js~CascadedData#insert",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "idx",
        "types": [
          "*"
        ]
      },
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 72,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/cascaded_data.js~CascadedData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascaded_data.js~CascadedData#serialize",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/cascaded_data.js~CascadedData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascaded_data.js~CascadedData#toArray",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "map",
    "memberof": "src/cascaded_data.js~CascadedData",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/cascaded_data.js~CascadedData#map",
    "access": "public",
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "file",
    "name": "src/config.js",
    "content": "/**\n * config.js\n */\n\nexport default {\n  ////////////////////////////////////////////////////////////\n  publicKeyIdLEN: 32,\n  publicKeyIdHash: 'SHA-256',\n\n  ////////////////////////////////////////////////////////////\n  sessionKeyIdLength: 32, // 8 byte session key id given from last 8 byte from sha 256 digest as public key id\n  sessionKeyIdHash: 'SHA-256', // for hash digest of session key\n\n  ////////////////////////////////////////////////////////////\n  // Suite-specific parameters below\n  ////////////////////////////////////////////////////////////\n  // jscu\n  jscu: {\n    // iv length for AES-GCM\n    ivLengthAesGcm: 12,\n  },\n\n  ////////////////////////////////////////////////////////////\n  // OpenPGP\n  openpgp : {\n    defaultUser : '<example@example.com>',\n\n    // openpgp.worker.js must be located in the place where api_openpgp.js and js-file bundling core-file.\n    // Namely in this project, they are located in 'dist',\n    // and it will be './', i.e., the root path of the url, from the viewpoint of bundled file.\n    workerPathWeb: './openpgp.worker.min.js',\n\n    workerPathNode: '../node_modules/openpgp/dist/openpgp.worker.min.js',\n  }\n};",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/config.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 76,
    "kind": "file",
    "name": "src/core.js",
    "content": "/**\n * core.js\n */\n\nimport {generateKeyObject} from './keys.js';\nimport {importMessage} from './message.js';\nimport {OpenPGP} from './suite_openpgp.js';\nimport {Jscu} from './suite_jscu.js';\n\n/**\n * Generate key (pair). This API must be called externally.\n * @param keyParams {object}: a parameter to generate keys in the form of like\n * OpenPGP:\n * { suite: 'openpgp',\n *   userIds,\n *   passphrase: 'omg',\n *   keyParams: { type: 'ECC', keyExpirationTime: 0, curve: 'P-256' } }\n * Simple Crypto Suite using WebCryptoAPI/OpenSSL:\n * { suite: 'jscu',\n *   passphrase: 'omg',\n *   keyParams: {type: 'ECC', curve} } }\n * @return {Promise<*>}\n */\nexport async function generateKey (keyParams) {\n  const keyObj = await generateKeyObject(keyParams);\n\n  // formatting\n  if (keyParams.keyParams.type === 'session') {\n    return keyObj;\n  }\n  else {\n    if(keyParams.suite === 'openpgp') { /** OpenPGP **/\n      return {\n        publicKey: { keyString: keyObj.publicKey.armor(), keyId: keyObj.keyId },\n        privateKey: Object.assign(\n          { keyString: keyObj.privateKey.armor(), keyId: keyObj.keyId },\n          (keyParams.passphrase) ? {passphrase: keyParams.passphrase} : {})\n      };\n    }\n    else if (keyParams.suite === 'jscu') { /** js-crypto-utils **/\n      return {\n        publicKey: {\n          keyString: await keyObj.publicKey.export('pem', {outputPublic: true}),\n          keyId: keyObj.keyId\n        },\n        privateKey: Object.assign(\n          { keyString: await keyObj.privateKey.export('pem'), keyId: keyObj.keyId },\n          (keyParams.passphrase) ? {passphrase: keyParams.passphrase} : {} )\n      };\n    }\n    else throw new Error('InvalidCryptoSuite');\n  }\n}\n\n/**\n * Basic encryption API that enables signing simultaneously with encrypting message.\n * @param message\n * @param keys\n * @param config\n * @return {Promise<{success: boolean, status: string, data: any}>}\n */\nexport async function encrypt({message, keys, config}){\n  // assertion\n  if (typeof config.encrypt === 'undefined') throw new Error('InvalidConfigForEncryption');\n  if (!keys.canEncrypt()) throw new Error('UnsupportedKeyForEncryption');\n\n  // compose objects\n  const msgObj = importMessage(message);\n\n  // do signing\n  let signed = {};\n  if (typeof config.sign !== 'undefined' && config.sign.required &&\n    (typeof config.encrypt === 'undefined' ||\n    (typeof config.encrypt !== 'undefined' && !(config.encrypt.suite === 'openpgp' && config.sign.suite === 'openpgp')))\n  ){\n    if (keys.suite.sign_verify !== config.sign.suite) throw new Error('UnmatchedKeyTypeToSigningSuite');\n    if (!keys.canSign()) throw new Error('UnsupportedKeyForSign');\n    signed = await cryptoSuite(keys.suite.sign_verify).sign({\n      message: msgObj, keys: keys.keys, options: config.sign.options\n    }).catch((e) => {\n      throw new Error(`SigningFailed: ${e.message}`);\n    });\n  }\n\n  // do encryption.\n  if (keys.suite.encrypt_decrypt !== config.encrypt.suite) throw new Error('UnmatchedKeyTypeToEncryptionSuite');\n  const encrypted = await cryptoSuite(keys.suite.encrypt_decrypt).encrypt({\n    message: msgObj, keys: keys.keys, options: config.encrypt.options\n  }).catch( (e) => { throw new Error(`EncryptionFailed: ${e.message}`); });\n\n  return Object.assign(encrypted, signed);\n}\n\n/**\n * Decrypt given message and additionally verify attached signatures simultaneously.\n * @param data\n * @param keys\n * @return {Promise<*>}\n */\nexport async function decrypt({data, keys}){\n  if(typeof data.message === 'undefined') throw new Error('InvalidEncryptedDataFormat');\n  if(!keys.canDecrypt()) throw new Error('UnsupportedKeyForDecryption');\n\n  // do decryption\n  if (keys.suite.encrypt_decrypt !== data.message.suite) throw new Error('UnmatchedKeyTypeToEncryptionSuite');\n  const decrypted = await cryptoSuite(keys.suite.encrypt_decrypt).decrypt({\n    encrypted: data, keys: keys.keys, options: data.message.options\n  }).catch( (e) => { console.error(e); throw new Error(`DecryptionFailed: ${e.message}`); });\n\n  // do verification\n  let verified = {};\n  if(typeof data.signature !== 'undefined' && keys.keys.publicKeys && keys.canVerify()) {\n    verified = await cryptoSuite(keys.suite.sign_verify).verify({\n      message: importMessage(decrypted.data),\n      signature: data.signature,\n      keys: keys.keys,\n      options: data.signature.options\n    }).catch((e) => {\n      throw new Error(`VerificationFailed: ${e.message}`);\n    });\n  }\n  else if (typeof decrypted.signatures !== 'undefined') verified = decrypted.signatures;\n\n  return {data: decrypted.data, signatures: verified};\n}\n\n/**\n * Returns the signature objects.\n * @param message\n * @param keys\n * @param config\n * @return {Promise<{success: boolean, status: string, data}>}\n */\nexport async function sign({message, keys, config}){\n  // assertion\n  if (typeof config.sign === 'undefined') throw new Error('InvalidConfigForSigning');\n  if (!keys.canSign()) throw new Error('UnsupportedKeyForSign');\n\n  // compose objects\n  const msgObj = importMessage(message);\n\n  // do signing\n  if(keys.keys.privateKeys) {\n    return await cryptoSuite(keys.suite.sign_verify).sign({\n      message: msgObj, keys: keys.keys, options: config.sign.options\n    }).catch((e) => {\n      throw new Error(`SigningFailed: ${e.message}`);\n    });\n  } else throw new Error('InvalidPrivateKeys');\n}\n\n/**\n * Returns verification result\n * @param message\n * @param signature\n * @param keys\n * @return {Promise<*>}\n */\nexport async function verify({message, signature, keys}){\n  // assertion\n  if (typeof signature === 'undefined') throw new Error('InvalidObjectForSignature');\n  if (!keys.canVerify()) throw new Error('UnsupportedKeyForVerification');\n\n  const msgObj = importMessage(message);\n\n  // do verification\n  if(typeof signature !== 'undefined' && keys.keys.publicKeys) {\n    return await cryptoSuite(keys.suite.sign_verify).verify({\n      message: msgObj, signature, keys: keys.keys, options: signature.options\n    }).catch((e) => {\n      throw new Error(`VerificationFailed: ${e.message}`);\n    });\n  } else throw new Error('InvalidSignatureOrInvalidPublicKey');\n}\n\nconst cryptoSuite = (suiteName) => {\n  let suiteObj;\n  if (suiteName === 'jscu') suiteObj = Jscu;\n  else if (suiteName === 'openpgp') suiteObj = OpenPGP;\n  else throw new Error('UnknownSuite');\n  return suiteObj;\n};",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/core.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "function",
    "name": "generateKey",
    "memberof": "src/core.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/core.js~generateKey",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/core.js",
    "importStyle": "{generateKey}",
    "description": "Generate key (pair). This API must be called externally.",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keyParams",
        "description": "{object}: a parameter to generate keys in the form of like\nOpenPGP:\n{ suite: 'openpgp',\n  userIds,\n  passphrase: 'omg',\n  keyParams: { type: 'ECC', keyExpirationTime: 0, curve: 'P-256' } }\nSimple Crypto Suite using WebCryptoAPI/OpenSSL:\n{ suite: 'jscu',\n  passphrase: 'omg',\n  keyParams: {type: 'ECC', curve} } }"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 78,
    "kind": "function",
    "name": "encrypt",
    "memberof": "src/core.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/core.js~encrypt",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/core.js",
    "importStyle": "{encrypt}",
    "description": "Basic encryption API that enables signing simultaneously with encrypting message.",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{success: boolean, status: string, data: any}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 79,
    "kind": "function",
    "name": "decrypt",
    "memberof": "src/core.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/core.js~decrypt",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/core.js",
    "importStyle": "{decrypt}",
    "description": "Decrypt given message and additionally verify attached signatures simultaneously.",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "sign",
    "memberof": "src/core.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/core.js~sign",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/core.js",
    "importStyle": "{sign}",
    "description": "Returns the signature objects.",
    "lineNumber": 134,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "config",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{success: boolean, status: string, data}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "verify",
    "memberof": "src/core.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/core.js~verify",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/core.js",
    "importStyle": "{verify}",
    "description": "Returns verification result",
    "lineNumber": 159,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "cryptoSuite",
    "memberof": "src/core.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/core.js~cryptoSuite",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/core.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [
      {
        "name": "suiteName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 83,
    "kind": "file",
    "name": "src/encrypted_message.js",
    "content": "/**\n * encrypted_message.js\n */\n\nimport {KeyId, KeyIdList, createKeyId, createKeyIdList} from './keyid.js';\nimport jseu from 'js-encoding-utils';\nimport cloneDeep from 'lodash.clonedeep';\nimport msgpack from 'msgpack-lite';\n\nconst suites = ['jscu', 'openpgp'];\nconst keyTypes = ['public_key_encrypt', 'session_key_encrypt'];\n\n\nexport function importEncryptedBuffer(serialized){\n  if (!(serialized instanceof Uint8Array)) throw new Error('NonUint8ArraySerializedData');\n  let des;\n  try {\n    des = msgpack.decode(serialized);\n  } catch (e) { throw new Error(`FailedToParseEncryptedMessageBuffer: ${e.message}`); }\n\n  if (!des.suite || !des.keyType || !des.message || !des.options) throw new Error('InvalidEncryptedMessageFormat');\n\n  const messageList = des.message.map( (elem) => {\n    let keyId;\n    if(elem.keyId instanceof Array) keyId = createKeyIdList(elem.keyId.map( (k) => createKeyId(new Uint8Array(k))));\n    else keyId = createKeyId(new Uint8Array(elem.keyId));\n    return createRawEncryptedMessage(elem.data, keyId, elem.params);\n  });\n\n  return createEncryptedMessage( des.suite, des.keyType, messageList, des.options );\n}\n\nexport function importRawEncryptedBufferList(array){\n  if (!(array instanceof Array)) throw new Error('NotArrayOfSerializedData');\n  array.forEach( (ser) => {\n    if(!(ser instanceof Uint8Array)) throw new Error('NotUint8ArraySerializedData');\n  });\n  let deserializedArray;\n  try {\n    deserializedArray = array.map( (ser) => {\n      const decoded = msgpack.decode(ser);\n      let keyId;\n      if(decoded.keyId instanceof Array) keyId = createKeyIdList(decoded.keyId.map( (k) => createKeyId(new Uint8Array(k))));\n      else keyId = createKeyId(new Uint8Array(decoded.keyId));\n      return createRawEncryptedMessage(decoded.data, keyId, decoded.params);\n    });\n  } catch (e) { throw new Error(`FailedToParseRawEncryptedMessage: ${e.message}`); }\n\n  return deserializedArray;\n}\n\n\nexport function createEncryptedMessage(suite, keyType, message, options = {}) {\n  // assertion\n  if (suites.indexOf(suite) < 0) throw new Error('UnsupportedSuite');\n  if (keyTypes.indexOf(keyType) < 0) throw new Error('UnsupportedKeyType');\n\n  return new EncryptedMessage(suite, keyType, message, options);\n}\n\nexport function createRawEncryptedMessage(data, keyId, params) {\n  if (!(data instanceof Uint8Array)) throw new Error('NonUint8ArrayData');\n  if (!(keyId instanceof KeyId) && !(keyId instanceof KeyIdList)) throw new Error('NonKeyIdOrKeyIdListObject');\n\n  return new RawEncryptedMessage(data, keyId, params);\n}\n\nexport class EncryptedMessage {\n  constructor(suite, keyType, message, options = {}) {\n    this._suite = suite;\n    this._keyType = keyType;\n    this._setMessage(message);\n    this._options = options;\n  }\n\n  _setMessage(message) {\n    this._message = new RawEncryptedMessageList();\n    this._message._set(message);\n  }\n\n  extract() {\n    const returnArray = cloneDeep(this._message);\n    this._message = new RawEncryptedMessageList();\n    this._message._set([]);\n    return returnArray.toArray();\n  }\n\n  insert(messageArray) {\n    this._message = new RawEncryptedMessageList();\n    this._message._set(messageArray);\n  }\n\n  get suite() { return this._suite; }\n  get keyType() { return this._keyType; }\n  get message() { return this._message; }\n  get options() { return this._options; }\n\n  serialize() {\n    return msgpack.encode({\n      suite: this._suite,\n      keyType: this._keyType,\n      message: this._message.toJsObject(),\n      options: this._options\n    });\n  }\n}\n\nexport class RawEncryptedMessage extends Uint8Array {\n  constructor(data, keyId, params = {}) {\n    super(data);\n    this._keyId = keyId;\n    this._params = params;\n  }\n\n  toBase64() { return jseu.encoder.encodeBase64(this); }\n\n  toBuffer() {\n    const buf = new Uint8Array(this);\n    return cloneDeep(buf);\n  }\n\n  toJsObject() {\n    return {\n      data: this.toBuffer(),\n      keyId: this._keyId.toBuffer(),\n      params: this._params\n    };\n  }\n\n  serialize() {\n    return msgpack.encode(this.toJsObject());\n  }\n\n  get keyId() { return this._keyId; }\n  get params() { return this._params; }\n}\n\nexport class RawEncryptedMessageList extends Array {\n  _set(message) {\n    if (!(message instanceof Array)) throw new Error('InvalidEncryptedMessageList');\n    const binaryMessage = message.map((m) => {\n      if (!(m instanceof RawEncryptedMessage)) throw new Error('NotEncryptedMessage');\n      return m;\n    });\n    this.push(...binaryMessage);\n  }\n\n  toJsObject() { return this.map((raw) => raw.toJsObject()); }\n  toArray() { return Array.from(this); }\n\n  map(callback) { return this.toArray().map(callback); }\n  filter(callback) { return this.toArray().filter(callback); }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/encrypted_message.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 84,
    "kind": "variable",
    "name": "suites",
    "memberof": "src/encrypted_message.js",
    "static": true,
    "longname": "src/encrypted_message.js~suites",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 85,
    "kind": "variable",
    "name": "keyTypes",
    "memberof": "src/encrypted_message.js",
    "static": true,
    "longname": "src/encrypted_message.js~keyTypes",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 86,
    "kind": "function",
    "name": "importEncryptedBuffer",
    "memberof": "src/encrypted_message.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/encrypted_message.js~importEncryptedBuffer",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{importEncryptedBuffer}",
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "params": [
      {
        "name": "serialized",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "function",
    "name": "importRawEncryptedBufferList",
    "memberof": "src/encrypted_message.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/encrypted_message.js~importRawEncryptedBufferList",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{importRawEncryptedBufferList}",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "function",
    "name": "createEncryptedMessage",
    "memberof": "src/encrypted_message.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/encrypted_message.js~createEncryptedMessage",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{createEncryptedMessage}",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "params": [
      {
        "name": "suite",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyType",
        "types": [
          "*"
        ]
      },
      {
        "name": "message",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "function",
    "name": "createRawEncryptedMessage",
    "memberof": "src/encrypted_message.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/encrypted_message.js~createRawEncryptedMessage",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{createRawEncryptedMessage}",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyId",
        "types": [
          "*"
        ]
      },
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 90,
    "kind": "class",
    "name": "EncryptedMessage",
    "memberof": "src/encrypted_message.js",
    "static": true,
    "longname": "src/encrypted_message.js~EncryptedMessage",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{EncryptedMessage}",
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 91,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "_suite",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#_suite",
    "access": "private",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "_keyType",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#_keyType",
    "access": "private",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "_options",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#_options",
    "access": "private",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "_setMessage",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#_setMessage",
    "access": "private",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "_message",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#_message",
    "access": "private",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "method",
    "name": "extract",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#extract",
    "access": "public",
    "description": null,
    "lineNumber": 81,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "method",
    "name": "insert",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#insert",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "messageArray",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 101,
    "kind": "get",
    "name": "suite",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#suite",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 102,
    "kind": "get",
    "name": "keyType",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#keyType",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "get",
    "name": "message",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#message",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "get",
    "name": "options",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#options",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/encrypted_message.js~EncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~EncryptedMessage#serialize",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "class",
    "name": "RawEncryptedMessage",
    "memberof": "src/encrypted_message.js",
    "static": true,
    "longname": "src/encrypted_message.js~RawEncryptedMessage",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{RawEncryptedMessage}",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "interface": false,
    "extends": [
      "Uint8Array"
    ]
  },
  {
    "__docId__": 107,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 109,
    "undocument": true
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "_keyId",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#_keyId",
    "access": "private",
    "description": null,
    "lineNumber": 111,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "_params",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#_params",
    "access": "private",
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 110,
    "kind": "method",
    "name": "toBase64",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#toBase64",
    "access": "public",
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 111,
    "kind": "method",
    "name": "toBuffer",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#toBuffer",
    "access": "public",
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 112,
    "kind": "method",
    "name": "toJsObject",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#toJsObject",
    "access": "public",
    "description": null,
    "lineNumber": 122,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"data\": *, \"keyId\": *, \"params\": *}"
      ]
    }
  },
  {
    "__docId__": 113,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#serialize",
    "access": "public",
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 114,
    "kind": "get",
    "name": "keyId",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#keyId",
    "access": "public",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "get",
    "name": "params",
    "memberof": "src/encrypted_message.js~RawEncryptedMessage",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessage#params",
    "access": "public",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "class",
    "name": "RawEncryptedMessageList",
    "memberof": "src/encrypted_message.js",
    "static": true,
    "longname": "src/encrypted_message.js~RawEncryptedMessageList",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/encrypted_message.js",
    "importStyle": "{RawEncryptedMessageList}",
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "interface": false,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 117,
    "kind": "method",
    "name": "_set",
    "memberof": "src/encrypted_message.js~RawEncryptedMessageList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessageList#_set",
    "access": "private",
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "params": [
      {
        "name": "message",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "toJsObject",
    "memberof": "src/encrypted_message.js~RawEncryptedMessageList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessageList#toJsObject",
    "access": "public",
    "description": null,
    "lineNumber": 148,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/encrypted_message.js~RawEncryptedMessageList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessageList#toArray",
    "access": "public",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "method",
    "name": "map",
    "memberof": "src/encrypted_message.js~RawEncryptedMessageList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessageList#map",
    "access": "public",
    "description": null,
    "lineNumber": 151,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "method",
    "name": "filter",
    "memberof": "src/encrypted_message.js~RawEncryptedMessageList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/encrypted_message.js~RawEncryptedMessageList#filter",
    "access": "public",
    "description": null,
    "lineNumber": 152,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "file",
    "name": "src/index.js",
    "content": "/**\n * index.js\n */\n\nimport {\n  generateKey,\n  encrypt,\n  decrypt,\n  sign,\n  verify\n} from './core.js';\nimport { createEncryptionCascade, createDecryptionCascade } from './cascade.js';\nimport { importKeys } from './keys.js';\nimport { importEncryptedBuffer, importRawEncryptedBufferList } from './encrypted_message.js';\nimport { importSignatureBuffer } from './signature.js';\nimport { importCascadedBuffer} from './cascaded_data.js';\nimport config from './config.js';\n\nexport default {\n  generateKey,\n  encrypt,\n  decrypt,\n  sign,\n  verify,\n  importKeys,\n  importEncryptedBuffer,\n  importRawEncryptedBufferList,\n  importSignatureBuffer,\n  importCascadedBuffer,\n  createEncryptionCascade,\n  createDecryptionCascade,\n  config\n};\nexport {\n  generateKey,\n  encrypt,\n  decrypt,\n  sign,\n  verify,\n  importKeys,\n  importEncryptedBuffer,\n  importRawEncryptedBufferList,\n  importSignatureBuffer,\n  importCascadedBuffer,\n  createEncryptionCascade,\n  createDecryptionCascade,\n  config\n};",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 123,
    "kind": "file",
    "name": "src/keyid.js",
    "content": "/**\n * keyid.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport config from './config.js';\nimport {getJscu} from './util.js';\nimport cloneDeep from 'lodash.clonedeep';\n\n/**\n * Calculate key id from openpgp key object\n * @param keyObject\n * @param len\n * @return {KeyId}\n */\nexport function fromOpenPgpKey(keyObject, len=config.publicKeyIdLEN){\n  const fp = keyObject.getFingerprint();\n  const buf = jseu.encoder.hexStringToArrayBuffer(fp);\n  return createKeyId(buf.slice(0, len));\n}\n\n/**\n * Calculate key Id from jwk-formatted key\n * Key id is defined as jwk public key thumbprint (NOTE: not private key thumbprint)\n * see the spec here => https://tools.ietf.org/html/rfc7638\n * @param keyObject\n * @param len\n * @return {Promise<KeyId>}\n */\nexport async function fromJscuKey(keyObject, len=config.publicKeyIdLEN) {\n  const thumbPrintBuf = await keyObject.getJwkThumbprint(config.publicKeyIdHash, 'binary');\n  return createKeyId(thumbPrintBuf.slice(0, len));\n}\n\n/**\n * Just a hash of raw binary key\n * @param bin\n * @param len\n * @return {Promise<KeyId>}\n */\nexport async function fromRawKey(bin, len = config.sessionKeyIdLength) {\n  const jscu = getJscu();\n  const digest = await jscu.hash.compute(bin, config.sessionKeyIdHash);\n  return createKeyId(digest.slice(0, len));\n}\n\n\nexport function createKeyId(keyId){\n  if(!(keyId instanceof Uint8Array)) throw new Error('NotUint8ArrayKeyId');\n  const localKeyId = cloneDeep(keyId);\n  return new KeyId(localKeyId);\n}\n\nexport class KeyId extends Uint8Array {\n  // eslint-disable-next-line no-useless-constructor\n  constructor(keyId){\n    super(keyId);\n  }\n\n  toHex() { return jseu.encoder.arrayBufferToHexString(this); }\n  toBuffer() {\n    const buf = new Uint8Array(this);\n    return cloneDeep(buf);\n  }\n}\n\n\n// NOTE: KeyIdList is used only for EncryptedMessage generated in OpenPGP.\nexport function createKeyIdList (keyIds) {\n  const obj = new KeyIdList();\n  obj._init(keyIds);\n  return obj;\n}\n\nexport class KeyIdList extends Array {\n  _init(keyIds){\n    if (!(keyIds instanceof Array)) throw new Error('InvalidKeyIdList');\n    const binaryKeyIds = keyIds.map( (k) => {\n      if(!(k instanceof KeyId)) throw new Error('NotKeyId');\n      return k;\n    });\n    this.push(...binaryKeyIds);\n  }\n  toBuffer() { return this.map( (kid) => kid.toBuffer()); }\n  toArray() { return Array.from(this); }\n\n  map(callback) { return this.toArray().map(callback); }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/keyid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 124,
    "kind": "function",
    "name": "fromOpenPgpKey",
    "memberof": "src/keyid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/keyid.js~fromOpenPgpKey",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{fromOpenPgpKey}",
    "description": "Calculate key id from openpgp key object",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keyObject",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "KeyId"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 125,
    "kind": "function",
    "name": "fromJscuKey",
    "memberof": "src/keyid.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/keyid.js~fromJscuKey",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{fromJscuKey}",
    "description": "Calculate key Id from jwk-formatted key\nKey id is defined as jwk public key thumbprint (NOTE: not private key thumbprint)\nsee the spec here => https://tools.ietf.org/html/rfc7638",
    "lineNumber": 30,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keyObject",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<KeyId>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 126,
    "kind": "function",
    "name": "fromRawKey",
    "memberof": "src/keyid.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/keyid.js~fromRawKey",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{fromRawKey}",
    "description": "Just a hash of raw binary key",
    "lineNumber": 41,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "bin",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "len",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<KeyId>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 127,
    "kind": "function",
    "name": "createKeyId",
    "memberof": "src/keyid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/keyid.js~createKeyId",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{createKeyId}",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "params": [
      {
        "name": "keyId",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "class",
    "name": "KeyId",
    "memberof": "src/keyid.js",
    "static": true,
    "longname": "src/keyid.js~KeyId",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{KeyId}",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "interface": false,
    "extends": [
      "Uint8Array"
    ]
  },
  {
    "__docId__": 129,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/keyid.js~KeyId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyId#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 56,
    "undocument": true
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "toHex",
    "memberof": "src/keyid.js~KeyId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyId#toHex",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "name": "toBuffer",
    "memberof": "src/keyid.js~KeyId",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyId#toBuffer",
    "access": "public",
    "description": null,
    "lineNumber": 61,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 132,
    "kind": "function",
    "name": "createKeyIdList",
    "memberof": "src/keyid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/keyid.js~createKeyIdList",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{createKeyIdList}",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [
      {
        "name": "keyIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 133,
    "kind": "class",
    "name": "KeyIdList",
    "memberof": "src/keyid.js",
    "static": true,
    "longname": "src/keyid.js~KeyIdList",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keyid.js",
    "importStyle": "{KeyIdList}",
    "description": null,
    "lineNumber": 75,
    "undocument": true,
    "interface": false,
    "extends": [
      "Array"
    ]
  },
  {
    "__docId__": 134,
    "kind": "method",
    "name": "_init",
    "memberof": "src/keyid.js~KeyIdList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyIdList#_init",
    "access": "private",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "keyIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 135,
    "kind": "method",
    "name": "toBuffer",
    "memberof": "src/keyid.js~KeyIdList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyIdList#toBuffer",
    "access": "public",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 136,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/keyid.js~KeyIdList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyIdList#toArray",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 137,
    "kind": "method",
    "name": "map",
    "memberof": "src/keyid.js~KeyIdList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keyid.js~KeyIdList#map",
    "access": "public",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 138,
    "kind": "file",
    "name": "src/keys.js",
    "content": "/**\n * keys.js\n */\n\nimport cloneDeep from 'lodash.clonedeep';//'lodash/cloneDeep';\nimport {Jscu} from './suite_jscu.js';\nimport {OpenPGP} from './suite_openpgp.js';\n\nexport class Keys {\n  async from(format, {keys, suite, mode}){\n    // assertion\n    if((mode.indexOf('encrypt') >= 0 && mode.indexOf('verify') >= 0)\n      || (mode.indexOf('encrypt') >= 0 && mode.indexOf('decrypt') >= 0)\n      || (mode.indexOf('decrypt') >= 0 && mode.indexOf('sign') >= 0)\n      || (mode.indexOf('sign') >= 0 && mode.indexOf('verify') >= 0)\n    ) throw new Error('InvalidMode');\n\n    if(mode.indexOf('encrypt') >= 0) {\n      if (typeof keys.publicKeys !== 'undefined'){\n        if (typeof keys.sessionKey !== 'undefined') throw new Error('SessionKeyAndPublicKeyAreExclusive');\n      } else {\n        if (typeof keys.sessionKey === 'undefined') throw new Error('NoSessionKeyOrPublicKeyIsGiven');\n      }\n    }\n\n    if(mode.indexOf('decrypt') >= 0) {\n      if (typeof keys.privateKeyPassSets !== 'undefined' || typeof keys.privateKeys !== 'undefined'){\n        if (typeof keys.sessionKey !== 'undefined') throw new Error('SessionKeyAndPrivateKeyAreExclusive');\n      } else {\n        if (typeof keys.sessionKey === 'undefined') throw new Error('NoSessionKeyOrPrivateKeyIsGiven');\n      }\n    }\n\n    if(mode.indexOf('sign') >= 0 && typeof keys.privateKeyPassSets === 'undefined' &&  typeof keys.privateKeys === 'undefined'){\n      throw new Error('NoPrivateKey');\n    }\n    if(mode.indexOf('verify') >= 0 && typeof keys.publicKeys === 'undefined'){\n      throw new Error('NoPublicKey');\n    }\n\n    let obj;\n    if (format === 'string') obj = await importKeyStrings({keys, suite, mode});\n    else if (format === 'object') obj = await importKeyObjects({keys, suite, mode});\n    else throw new Error('UnsupportedAtThisPoint');\n\n    this._keys = obj.keys;\n    this._suite = obj.suite;\n    this._mode = obj.mode;\n\n    return true;\n  }\n\n  get keys () { return this._keys; }\n  get suite () { return this._suite; }\n  get mode () { return this._mode; }\n\n  canEncrypt() { return this.mode.indexOf('encrypt') >= 0; }\n  canDecrypt() { return this.mode.indexOf('decrypt') >= 0; }\n  canSign() { return this.mode.indexOf('sign') >= 0; }\n  canVerify() { return this.mode.indexOf('verify') >= 0; }\n\n}\n\n/**\n * Functions to import keys and translate them to suite-specific key objects.\n * @param format\n * @param keys\n * @param suite\n * @param mode\n * @return {Promise<Keys>}\n */\nexport async function importKeys(format='string', {keys, suite, mode}){\n  const localFormat = cloneDeep(format);\n  const localKeys = cloneDeep(keys);\n  const localSuite = cloneDeep(suite);\n  const localMode = cloneDeep(mode);\n\n  const keyObj = new Keys();\n  await keyObj.from(localFormat, {keys: localKeys, suite: localSuite, mode: localMode});\n  return keyObj;\n}\n\n\n/**\n * import from keystring, i.e., pem\n * @param keys\n * @param suite\n * @param mode\n * @return {Promise<{keys, suite: *, mode: *}>}\n */\nasync function importKeyStrings({keys, suite, mode}){\n  const keyObjects = {};\n\n  if (keys.sessionKey) keyObjects.sessionKey = keys.sessionKey; // symmetric key\n\n  const modes = [\n    {name: 'encrypt_decrypt', op: {public: 'encrypt', private: 'decrypt'}},\n    {name: 'sign_verify', op: {public: 'verify', private: 'sign'}}\n  ];\n  await Promise.all(modes.map( async (modeOjbect) => {\n    if(typeof suite[modeOjbect.name] !== 'undefined') {\n\n\n      let suiteObj;\n      if (suite[modeOjbect.name] === 'jscu') suiteObj = Jscu;\n      else if (suite[modeOjbect.name] === 'openpgp') suiteObj = OpenPGP;\n      else throw new Error('InvalidSuite');\n\n      if (mode.indexOf(modeOjbect.op.public) >= 0) {\n        if (keys.publicKeys) keyObjects.publicKeys = await Promise.all(keys.publicKeys.map( (pk) => suiteObj.importKey('pem', pk)));\n      }\n      else if (mode.indexOf(modeOjbect.op.private) >= 0) {\n        if (keys.privateKeyPassSets) {\n          keyObjects.privateKeys = await Promise.all(\n            keys.privateKeyPassSets.map((pkps) => suiteObj.importKey('pem', pkps.privateKey, pkps.passphrase))\n          );\n        }\n      }\n      else throw new Error('InvalidKeyMode');\n    }\n  }));\n\n  return { keys: keyObjects, suite, mode };\n}\n\n/**\n * just import from key object\n * @param keys\n * @param suite\n * @param mode\n * @return {Promise<{keys, suite: *, mode: *}>}\n */\nasync function importKeyObjects({keys, suite, mode}){\n  const keyObjects = {};\n\n  if (keys.sessionKey) keyObjects.sessionKey = keys.sessionKey; // symmetric key\n\n  if (keys.publicKeys) keyObjects.publicKeys = keys.publicKeys;\n\n  if (keys.privateKeys) keyObjects.privateKeys = keys.privateKeys;\n\n  return {keys: keyObjects, suite, mode};\n}\n\n\n/**\n * Basic key generator via openpgp/jscu APIs. Returns raw objects of keys in both environments from the spec with some additional args.\n * @param keyParams\n * @return {Promise<*>}\n */\nexport async function generateKeyObject(keyParams) {\n  const localKeyParams = cloneDeep(keyParams);\n  let returnKey;\n  if (localKeyParams.suite === 'openpgp') { /** OpenPGP **/\n    returnKey = await OpenPGP.generateKey({\n      userIds: localKeyParams.userIds,\n      passphrase: localKeyParams.passphrase,\n      params: localKeyParams.keyParams\n    })\n      .catch((e) => {\n        throw new Error(`GPGKeyGenerationFailed: ${e.message}`);\n      });\n\n  }\n  else if (localKeyParams.suite === 'jscu') { /** js-crypto-utils **/\n    returnKey = await Jscu.generateKey({\n      passphrase: localKeyParams.passphrase,\n      params: localKeyParams.keyParams,\n      encryptOptions: localKeyParams.encryptOptions\n    })\n      .catch((e) => {\n        throw new Error(`JscuKeyGenerationFailed: ${e.message}`);\n      });\n  }\n  else throw new Error('UnsupportedCryptoSuite');\n\n  return returnKey;\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/keys.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 139,
    "kind": "class",
    "name": "Keys",
    "memberof": "src/keys.js",
    "static": true,
    "longname": "src/keys.js~Keys",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keys.js",
    "importStyle": "{Keys}",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 140,
    "kind": "method",
    "name": "from",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/keys.js~Keys#from",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "params": [
      {
        "name": "format",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"keys\": *, \"suite\": *, \"mode\": *}"
        ],
        "defaultRaw": {
          "keys": null,
          "suite": null,
          "mode": null
        },
        "defaultValue": "{\"keys\":null,\"suite\":null,\"mode\":null}"
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "_keys",
    "memberof": "src/keys.js~Keys",
    "static": false,
    "longname": "src/keys.js~Keys#_keys",
    "access": "private",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "_suite",
    "memberof": "src/keys.js~Keys",
    "static": false,
    "longname": "src/keys.js~Keys#_suite",
    "access": "private",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "_mode",
    "memberof": "src/keys.js~Keys",
    "static": false,
    "longname": "src/keys.js~Keys#_mode",
    "access": "private",
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "get",
    "name": "keys",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#keys",
    "access": "public",
    "description": null,
    "lineNumber": 53,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "get",
    "name": "suite",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#suite",
    "access": "public",
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "get",
    "name": "mode",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#mode",
    "access": "public",
    "description": null,
    "lineNumber": 55,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "canEncrypt",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#canEncrypt",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "canDecrypt",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#canDecrypt",
    "access": "public",
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "canSign",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#canSign",
    "access": "public",
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "canVerify",
    "memberof": "src/keys.js~Keys",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/keys.js~Keys#canVerify",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "function",
    "name": "importKeys",
    "memberof": "src/keys.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/keys.js~importKeys",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keys.js",
    "importStyle": "{importKeys}",
    "description": "Functions to import keys and translate them to suite-specific key objects.",
    "lineNumber": 72,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "format",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "suite",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Keys>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 152,
    "kind": "function",
    "name": "importKeyStrings",
    "memberof": "src/keys.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/keys.js~importKeyStrings",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/keys.js",
    "importStyle": null,
    "description": "import from keystring, i.e., pem",
    "lineNumber": 91,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "suite",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{keys, suite: *, mode: *}>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 153,
    "kind": "function",
    "name": "importKeyObjects",
    "memberof": "src/keys.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/keys.js~importKeyObjects",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/keys.js",
    "importStyle": null,
    "description": "just import from key object",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "suite",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "mode",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{keys, suite: *, mode: *}>"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 154,
    "kind": "function",
    "name": "generateKeyObject",
    "memberof": "src/keys.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/keys.js~generateKeyObject",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/keys.js",
    "importStyle": "{generateKeyObject}",
    "description": "Basic key generator via openpgp/jscu APIs. Returns raw objects of keys in both environments from the spec with some additional args.",
    "lineNumber": 151,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keyParams",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 155,
    "kind": "file",
    "name": "src/message.js",
    "content": "/**\n * message.js\n */\n\nimport jseu from 'js-encoding-utils';\nimport cloneDeep from 'lodash.clonedeep'; //'lodash/cloneDeep';\n\n/**\n * import message and translate it to message object.\n * @param msg\n * @return {Message}\n */\nexport function importMessage(msg){\n  const localMessage = cloneDeep(msg);\n  const obj = new Message();\n  obj._init(localMessage);\n  return obj;\n}\n\nclass Message {\n  _init(msg){\n    if(msg instanceof Uint8Array){\n      this._message = msg;\n      this._messageType = 'binary';\n    }\n    else if (typeof msg === 'string'){\n      this._message = jseu.encoder.stringToArrayBuffer(msg);\n      this._messageType = 'string';\n    }\n    else throw new Error('UnsupportedMessageType');\n  }\n\n  get binary () { // returns message in binary format\n    return this._message;\n  }\n\n  get message () { // return message in original format\n    if(this.messageType === 'binary') return this._message;\n    else if (this.messageType === 'string') return jseu.encoder.arrayBufferToString(this._message);\n    else return null;\n  }\n  get messageType () { return this._messageType; }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/message.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 156,
    "kind": "function",
    "name": "importMessage",
    "memberof": "src/message.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/message.js~importMessage",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/message.js",
    "importStyle": "{importMessage}",
    "description": "import message and translate it to message object.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "msg",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Message"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 157,
    "kind": "class",
    "name": "Message",
    "memberof": "src/message.js",
    "static": true,
    "longname": "src/message.js~Message",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/message.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "_init",
    "memberof": "src/message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/message.js~Message#_init",
    "access": "private",
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "msg",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "_message",
    "memberof": "src/message.js~Message",
    "static": false,
    "longname": "src/message.js~Message#_message",
    "access": "private",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "_messageType",
    "memberof": "src/message.js~Message",
    "static": false,
    "longname": "src/message.js~Message#_messageType",
    "access": "private",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "get",
    "name": "binary",
    "memberof": "src/message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/message.js~Message#binary",
    "access": "public",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "get",
    "name": "message",
    "memberof": "src/message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/message.js~Message#message",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "get",
    "name": "messageType",
    "memberof": "src/message.js~Message",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/message.js~Message#messageType",
    "access": "public",
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "file",
    "name": "src/signature.js",
    "content": "/**\n * signature\n */\nimport {KeyId, createKeyId} from './keyid.js';\nimport jseu from 'js-encoding-utils';\nimport cloneDeep from 'lodash.clonedeep';\nimport msgpack from 'msgpack-lite';\n\nconst suites = ['jscu', 'openpgp'];\nconst keyTypes = ['public_key_sign'];\n\nexport function importSignatureBuffer(serialized){\n  if (!(serialized instanceof Uint8Array)) throw new Error('NonUint8ArraySerializedData');\n  let des;\n  try {\n    des = msgpack.decode(serialized);\n  } catch (e) { throw new Error(`FailedToParseSignatureBuffer: ${e.message}`); }\n\n  if (!des.suite || !des.keyType || !des.signatures || !des.options) throw new Error('InvalidSignatureFormat');\n\n  const signatureList = des.signatures.map( (elem) => createRawSignature(elem.data, createKeyId(elem.keyId)) );\n\n  return createSignature(des.suite, des.keyType, signatureList, des.options );\n}\n\nexport function createSignature(suite, keyType, signatures, options = {}){\n  // assertion\n  if(suites.indexOf(suite) < 0) throw new Error('UnsupportedSuite');\n  if(keyTypes.indexOf(keyType) < 0) throw new Error('UnsupportedKeyType');\n  if(suite === 'jscu' && typeof options.hash === 'undefined') throw new Error('HashMustBeSpecified');\n  if (!(signatures instanceof Array)) throw new Error('InvalidSignatureList');\n\n  return new Signature(suite, keyType, signatures, options);\n}\n\nexport class Signature {\n  constructor(suite, keyType, signatures, options = {}){\n    this._suite = suite;\n    this._keyType = keyType;\n    this._signatures = new SignatureList(signatures);\n    this._options = options;\n  }\n\n  get suite () { return this._suite; }\n  get keyType () { return this._keyType; }\n  get signatures () { return this._signatures; }\n  get options () { return this._options; }\n\n  serialize () {\n    return msgpack.encode({\n      suite: this._suite,\n      keyType: this._keyType,\n      signatures: this._signatures.toJsObject(),\n      options: this._options\n    });\n  }\n}\n\nclass SignatureList extends Array {\n  constructor(signatures){\n    super();\n    const binarySignatures = signatures.map( (sig) => {\n      if(!(sig instanceof RawSignature)) throw new Error('NotRawSignatureObject');\n      return sig;\n    });\n    this.push(...binarySignatures);\n  }\n\n  toJsObject() { return this.map( (s) => s.toJsObject() ); }\n  toArray() { return Array.from(this); }\n\n  map(callback) { return this.toArray().map(callback); }\n  filter(callback) { return this.toArray().filter(callback); }\n}\n\nexport function createRawSignature(sig, keyId){\n  // assertion\n  if(!(sig instanceof Uint8Array)) throw new Error('NonUint8ArraySignature');\n  if(!(keyId instanceof KeyId)) throw new Error('NonKeyIdObject');\n\n  return new RawSignature(sig, keyId);\n}\n\nexport class RawSignature extends Uint8Array {\n  constructor(sig, keyId){\n    super(sig);\n    this._keyId = keyId;\n  }\n\n  toBase64 () { return jseu.encoder.encodeBase64(this); }\n  toBuffer () { const buf = new Uint8Array(this);\n    return cloneDeep(buf);\n  }\n  toJsObject () {\n    return {\n      data: this.toBuffer(),\n      keyId: this._keyId.toBuffer(),\n    };\n  }\n\n  get keyId () { return this._keyId; }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/signature.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 167,
    "kind": "variable",
    "name": "suites",
    "memberof": "src/signature.js",
    "static": true,
    "longname": "src/signature.js~suites",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 168,
    "kind": "variable",
    "name": "keyTypes",
    "memberof": "src/signature.js",
    "static": true,
    "longname": "src/signature.js~keyTypes",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 169,
    "kind": "function",
    "name": "importSignatureBuffer",
    "memberof": "src/signature.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/signature.js~importSignatureBuffer",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": "{importSignatureBuffer}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "params": [
      {
        "name": "serialized",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "createSignature",
    "memberof": "src/signature.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/signature.js~createSignature",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": "{createSignature}",
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [
      {
        "name": "suite",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyType",
        "types": [
          "*"
        ]
      },
      {
        "name": "signatures",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "class",
    "name": "Signature",
    "memberof": "src/signature.js",
    "static": true,
    "longname": "src/signature.js~Signature",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": "{Signature}",
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 172,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/signature.js~Signature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~Signature#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true
  },
  {
    "__docId__": 173,
    "kind": "member",
    "name": "_suite",
    "memberof": "src/signature.js~Signature",
    "static": false,
    "longname": "src/signature.js~Signature#_suite",
    "access": "private",
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "member",
    "name": "_keyType",
    "memberof": "src/signature.js~Signature",
    "static": false,
    "longname": "src/signature.js~Signature#_keyType",
    "access": "private",
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "_signatures",
    "memberof": "src/signature.js~Signature",
    "static": false,
    "longname": "src/signature.js~Signature#_signatures",
    "access": "private",
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "_options",
    "memberof": "src/signature.js~Signature",
    "static": false,
    "longname": "src/signature.js~Signature#_options",
    "access": "private",
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "get",
    "name": "suite",
    "memberof": "src/signature.js~Signature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~Signature#suite",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "get",
    "name": "keyType",
    "memberof": "src/signature.js~Signature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~Signature#keyType",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "get",
    "name": "signatures",
    "memberof": "src/signature.js~Signature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~Signature#signatures",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "get",
    "name": "options",
    "memberof": "src/signature.js~Signature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~Signature#options",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "serialize",
    "memberof": "src/signature.js~Signature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~Signature#serialize",
    "access": "public",
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "class",
    "name": "SignatureList",
    "memberof": "src/signature.js",
    "static": true,
    "longname": "src/signature.js~SignatureList",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "interface": false,
    "extends": [
      "Array"
    ],
    "ignore": true
  },
  {
    "__docId__": 183,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/signature.js~SignatureList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~SignatureList#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "toJsObject",
    "memberof": "src/signature.js~SignatureList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~SignatureList#toJsObject",
    "access": "public",
    "description": null,
    "lineNumber": 69,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "toArray",
    "memberof": "src/signature.js~SignatureList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~SignatureList#toArray",
    "access": "public",
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "map",
    "memberof": "src/signature.js~SignatureList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~SignatureList#map",
    "access": "public",
    "description": null,
    "lineNumber": 72,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "filter",
    "memberof": "src/signature.js~SignatureList",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~SignatureList#filter",
    "access": "public",
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "params": [
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 188,
    "kind": "function",
    "name": "createRawSignature",
    "memberof": "src/signature.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/signature.js~createRawSignature",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": "{createRawSignature}",
    "description": null,
    "lineNumber": 76,
    "undocument": true,
    "params": [
      {
        "name": "sig",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyId",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "class",
    "name": "RawSignature",
    "memberof": "src/signature.js",
    "static": true,
    "longname": "src/signature.js~RawSignature",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/signature.js",
    "importStyle": "{RawSignature}",
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "interface": false,
    "extends": [
      "Uint8Array"
    ]
  },
  {
    "__docId__": 190,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/signature.js~RawSignature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~RawSignature#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 85,
    "undocument": true
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "_keyId",
    "memberof": "src/signature.js~RawSignature",
    "static": false,
    "longname": "src/signature.js~RawSignature#_keyId",
    "access": "private",
    "description": null,
    "lineNumber": 87,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "toBase64",
    "memberof": "src/signature.js~RawSignature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~RawSignature#toBase64",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 193,
    "kind": "method",
    "name": "toBuffer",
    "memberof": "src/signature.js~RawSignature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~RawSignature#toBuffer",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 194,
    "kind": "method",
    "name": "toJsObject",
    "memberof": "src/signature.js~RawSignature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~RawSignature#toJsObject",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "{\"data\": *, \"keyId\": *}"
      ]
    }
  },
  {
    "__docId__": 195,
    "kind": "get",
    "name": "keyId",
    "memberof": "src/signature.js~RawSignature",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/signature.js~RawSignature#keyId",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "file",
    "name": "src/suite.js",
    "content": "/**\n * suite.js\n */\n\nexport class Suite {\n  constructor() {\n    if (new.target === Suite) {\n      throw new TypeError('SuiteClassCannotBeInstantiatedDirectly');\n    }\n    if (\n      this.constructor.generateKey === undefined ||\n      this.constructor.encrypt === undefined ||\n      this.constructor.decrypt === undefined ||\n      this.constructor.sign === undefined ||\n      this.constructor.verify === undefined ||\n      this.constructor.importKey === undefined\n    ) {\n      throw new TypeError('MustOverrideAllMethods');\n    }\n  }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/suite.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 197,
    "kind": "class",
    "name": "Suite",
    "memberof": "src/suite.js",
    "static": true,
    "longname": "src/suite.js~Suite",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/suite.js",
    "importStyle": "{Suite}",
    "description": "suite.js",
    "lineNumber": 5,
    "interface": false
  },
  {
    "__docId__": 198,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/suite.js~Suite",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/suite.js~Suite#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 6,
    "undocument": true
  },
  {
    "__docId__": 199,
    "kind": "file",
    "name": "src/suite_jscu.js",
    "content": "/**\n * suite_jscu.js\n */\n\nimport {Suite} from './suite.js';\nimport {getJscu} from './util.js';\nimport * as utilKeyId from './keyid.js';\nimport config from './config.js';\nimport {createEncryptedMessage, createRawEncryptedMessage} from './encrypted_message.js';\nimport {createSignature, createRawSignature} from './signature.js';\n\nexport class Jscu extends Suite {\n  /**\n   * Generate publicKeyPair or sessionKeyObject with js-crypto-utils.\n   * @param params {Object}\n   * @param passphrase {string}\n   * @param encryptOptions {Object}\n   * @return {Promise<*>}\n   */\n  static async generateKey({params, passphrase=null, encryptOptions={}}) {\n    const jscu = getJscu();\n\n    if (params.type === 'session') {\n      if (!params.length) throw new Error('params.length must be specified');\n      const rawKey = await jscu.random.getRandomBytes(params.length);\n      const keyId = await utilKeyId.fromRawKey(rawKey);\n      return { key: rawKey, keyId };\n    }\n    else if (params.type === 'ec' || params.type === 'rsa') {\n      const keyType = (params.type === 'ec') ? 'EC' : 'RSA';\n      const options = (params.type === 'ec') ? {namedCurve: params.curve} : {modulusLength: params.modulusLength};\n\n      const keyObject = await jscu.pkc.generateKey(keyType, options);\n\n      const keyId = await utilKeyId.fromJscuKey(keyObject.publicKey);\n\n      // for encrypted keys\n      if (passphrase) {\n        const encryptedDer = await keyObject.privateKey.export('der', {encryptParams: Object.assign({passphrase}, encryptOptions)});\n        keyObject.privateKey  = new jscu.Key('der', encryptedDer);\n      }\n\n      return { publicKey: keyObject.publicKey, privateKey: keyObject.privateKey, keyId };\n    }\n    else throw new Error('JscuUnsupportedKeyType');\n  }\n\n  /**\n   * Import jscu key object\n   * @param type\n   * @param key\n   * @param passphrase\n   * @return {Promise<jscu.Key>}\n   */\n  static async importKey(type, key, passphrase){\n    const jscu = getJscu();\n\n    const keyObj = new jscu.Key(type, key);\n\n    if(keyObj.isPrivate && keyObj.isEncrypted){\n      if(!passphrase) throw new Error('PassphraseRequired');\n      await keyObj.decrypt(passphrase).catch( (e) => {\n        throw new Error(`FailedToDecryptPrivateKey: ${e.message}`);\n      });\n    }\n\n    return keyObj;\n  }\n\n  /**\n   * Encrypt plaintext object with given keys.\n   * @param message\n   * @param keys\n   * @param options\n   * @return {Promise<{message: EncryptedMessage}>}\n   */\n  static async encrypt({message, keys, options}) {\n    const jscu = getJscu();\n\n    // check options\n    if(typeof options === 'undefined') options = {};\n\n    // encryption\n    let encrypted;\n    let encryptedObject;\n    if (keys.publicKeys) { // public key encryption\n\n      if(options.privateKeyPass){ // for ECDH TODO: Reconsider if the pem formatted key could be assumed.\n        options.privateKey = await Jscu.importKey('pem', options.privateKeyPass.privateKey, options.privateKeyPass.passphrase);\n        delete options.privateKeyPass;\n      }\n\n      // for ecdh ephemeral keys\n      if(!options.privateKey) {\n        const jwk = await keys.publicKeys[0].export('jwk'); // TODO KeyType and curves should be retrieved directly from the object?\n        if (jwk.kty === 'EC'){\n          const ephemeral = await jscu.pkc.generateKey('EC', {namedCurve: jwk.crv});\n          options.privateKey = ephemeral.privateKey;\n        }\n      }\n\n      encrypted = await Promise.all(keys.publicKeys.map( async (publicKeyObj) => {\n        const data = await jscu.pkc.encrypt(message.binary, publicKeyObj, options);\n        const fed = new Uint8Array(data.data);\n        delete data.data;\n        return createRawEncryptedMessage(fed, await utilKeyId.fromJscuKey(publicKeyObj), data);\n      }));\n\n      // for ecdh, remove private key and add public key in encryption config, and add the config to the encrypted object\n      if(typeof options.privateKey !== 'undefined'){\n        options.publicKey = await options.privateKey.export('der', {outputPublic: true}); // export public key from private key\n        delete options.privateKey;\n      }\n\n      encryptedObject = {message: createEncryptedMessage('jscu', 'public_key_encrypt', encrypted, options)};\n    }\n    else if (keys.sessionKey) { // symmetric key encryption\n      if(options.name === 'AES-GCM') {  // TODO: other iv-required algorithms\n        const iv = await jscu.random.getRandomBytes(config.jscu.ivLengthAesGcm);\n        const data = await jscu.aes.encrypt(message.binary, keys.sessionKey, {name: options.name, iv});\n        const keyId = await utilKeyId.fromRawKey(keys.sessionKey);\n        const obj = createRawEncryptedMessage(data, keyId, {iv});\n        encrypted = [obj]; // TODO, should be an Array?\n      }\n      else throw new Error('JscuInvalidEncryptionAlgorithm');\n      encryptedObject = {message: createEncryptedMessage('jscu', 'session_key_encrypt', encrypted, options)};\n    }\n    else throw new Error('JscuInvalidEncryptionKey');\n\n    return encryptedObject;\n  }\n\n  /**\n   * Decrypt encrypted object with given keys.\n   * @param encrypted\n   * @param keys\n   * @param options\n   * @return {Promise<{data: *}>}\n   */\n  static async decrypt({encrypted, keys, options}) {\n    if (typeof encrypted.message === 'undefined') throw new Error('InvalidEncryptedMessage'); // TODO, change according to the class\n    if (!(encrypted.message.message instanceof Array)) throw new Error('NonArrayMessage');\n    const jscu = getJscu();\n\n    let decrypted;\n    ////////////////////////////////////////////////////////////////////\n    if (encrypted.message.keyType === 'public_key_encrypt'){\n      // public key decryption\n      if (!keys.privateKeys) throw new Error('JscuPrivateKeyRequired');\n      if (options.publicKey){\n        options.publicKey = await Jscu.importKey('der', options.publicKey);\n      }\n\n      // function definition\n      const decryptMessageObject = async (msgObject, privateKeyObject) => {\n        const data = msgObject.toBuffer();\n        const salt = (typeof msgObject.params.salt !== 'undefined') ? msgObject.params.salt : undefined;\n        const iv = (typeof msgObject.params.iv !== 'undefined') ? msgObject.params.iv : undefined;\n        const decOptions = Object.assign({ salt, iv }, options);\n        return await jscu.pkc.decrypt(data, privateKeyObject, decOptions);\n      };\n\n      // filter by keyId\n      const msgKeySet = [];\n      await Promise.all(keys.privateKeys.map( async (pk) => {\n        const keyId = await utilKeyId.fromJscuKey(pk);\n        const filtered = encrypted.message.message.filter( (m) => (m.keyId.toHex() === keyId.toHex()));\n        msgKeySet.push(...filtered.map((m) => ({message: m, privateKey: pk}) ));\n      }));\n      if (msgKeySet.length === 0) throw new Error('UnableToDecryptWithGivenPrivateKey');\n      // decrypt\n      let errMsg = '';\n      const decryptedArray = await Promise.all(msgKeySet.map( async (set) => {\n        const d = await decryptMessageObject(set.message, set.privateKey).catch( (e) => { errMsg = e.message; });\n        if(d) return d;\n        else return null;\n      }));\n      const returnArray = decryptedArray.filter( (d) => (d !== null));\n\n      if(returnArray.length > 0) decrypted = returnArray[0];\n      else throw new Error(errMsg);\n\n    }\n    ////////////////////////////////////////////////////////////////////\n    else if (encrypted.message.keyType === 'session_key_encrypt'){\n      // session key decryption\n      if (!keys.sessionKey) throw new Error('JscuSessionKeyRequired');\n      if (!(encrypted.message.message instanceof Array)) throw new Error('NonArrayMessage');\n\n      const message = encrypted.message.message[0]; // TODO Should be an array?\n      const iv = (typeof message.params.iv !== 'undefined') ? message.params.iv : null;\n\n      if(options.name === 'AES-GCM') {\n        decrypted = await jscu.aes.decrypt(\n          message.toBuffer(),\n          keys.sessionKey,\n          {name: keys.sessionKey.algorithm, iv}\n        );\n      }\n      else throw new Error('JscuInvalidEncryptionAlgorithm');\n    }\n    else throw new Error('JscuInvalidKeyType_NotSessionKey');\n\n    return {data: decrypted};\n  }\n\n  /**\n   * Signing on a message with given private key's'\n   * @param message\n   * @param keys\n   * @param options\n   * @return {Promise<{signature: Signature}>}\n   */\n  static async sign({message, keys, options}){\n    if(!keys.privateKeys) throw new Error('JscuInvalidSigningKeys');\n\n    const jscu = getJscu();\n\n    const signatures = await Promise.all(keys.privateKeys.map( async (privKey) => {\n      const signature = await jscu.pkc.sign(message.binary, privKey, options.hash, Object.assign({format: 'raw'}, options));\n      const keyId = await utilKeyId.fromJscuKey(privKey);\n\n      return createRawSignature(signature, keyId);\n    }));\n\n    return {signature: createSignature('jscu', 'public_key_sign', signatures, options) };\n  }\n\n  /**\n   * Verify signature here\n   * @param message\n   * @param signature\n   * @param keys\n   * @param options\n   * @return {Promise<{keyId: *, valid: *}[]>}\n   */\n  static async verify({message, signature, keys, options}){\n    if(!keys.publicKeys) throw new Error('JscuInvalidVerificationKeys');\n\n    const jscu = getJscu();\n\n    const signatureKeySet = [];\n    const unverified = [];\n    await Promise.all(keys.publicKeys.map( async (pk) => {\n      const keyId = await utilKeyId.fromJscuKey(pk);\n      const filtered = signature.signatures.filter( (s) => {\n        if(s.keyId.toHex() === keyId.toHex()) return true;\n        else{\n          unverified.push({keyId: s.keyId, valid: undefined});\n          return false;\n        }\n      }); // WA\n      signatureKeySet.push(...filtered.map((s) => ({signature: s, publicKey: pk}) ));\n    }));\n\n    const verified = await Promise.all(signatureKeySet.map( async (sigKey) => {\n      const valid = await jscu.pkc.verify(\n        message.binary,\n        sigKey.signature.toBuffer(),\n        sigKey.publicKey,\n        options.hash,\n        Object.assign({format: 'raw'}, options)\n      );\n      return {keyId: sigKey.signature.keyId, valid};\n    }));\n\n    return verified.concat(unverified);\n  }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/suite_jscu.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 200,
    "kind": "class",
    "name": "Jscu",
    "memberof": "src/suite_jscu.js",
    "static": true,
    "longname": "src/suite_jscu.js~Jscu",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/suite_jscu.js",
    "importStyle": "{Jscu}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/suite.js~Suite"
    ]
  },
  {
    "__docId__": 201,
    "kind": "method",
    "name": "generateKey",
    "memberof": "src/suite_jscu.js~Jscu",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_jscu.js~Jscu.generateKey",
    "access": "public",
    "description": "Generate publicKeyPair or sessionKeyObject with js-crypto-utils.",
    "lineNumber": 20,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "{Object}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "{string}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "encryptOptions",
        "description": "{Object}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 202,
    "kind": "method",
    "name": "importKey",
    "memberof": "src/suite_jscu.js~Jscu",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_jscu.js~Jscu.importKey",
    "access": "public",
    "description": "Import jscu key object",
    "lineNumber": 55,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<jscu.Key>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 203,
    "kind": "method",
    "name": "encrypt",
    "memberof": "src/suite_jscu.js~Jscu",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_jscu.js~Jscu.encrypt",
    "access": "public",
    "description": "Encrypt plaintext object with given keys.",
    "lineNumber": 77,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{message: EncryptedMessage}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 204,
    "kind": "method",
    "name": "decrypt",
    "memberof": "src/suite_jscu.js~Jscu",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_jscu.js~Jscu.decrypt",
    "access": "public",
    "description": "Decrypt encrypted object with given keys.",
    "lineNumber": 140,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "encrypted",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{data: *}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 205,
    "kind": "method",
    "name": "sign",
    "memberof": "src/suite_jscu.js~Jscu",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_jscu.js~Jscu.sign",
    "access": "public",
    "description": "Signing on a message with given private key's'",
    "lineNumber": 214,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{signature: Signature}>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 206,
    "kind": "method",
    "name": "verify",
    "memberof": "src/suite_jscu.js~Jscu",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_jscu.js~Jscu.verify",
    "access": "public",
    "description": "Verify signature here",
    "lineNumber": 237,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<{keyId: *, valid: *}[]>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 207,
    "kind": "file",
    "name": "src/suite_openpgp.js",
    "content": "/**\n * suite_openpgp.js\n */\nimport jseu from 'js-encoding-utils';\nimport {getOpenPgp} from './util.js';\nimport {Suite} from './suite.js';\nimport config from './config.js';\nimport * as utilKeyId from './keyid.js';\nimport {createRawSignature, createSignature, RawSignature} from './signature.js';\nimport {createEncryptedMessage, createRawEncryptedMessage} from './encrypted_message.js';\n\n\n// mapping names of curve\nconst curveList = {\n  'P-256': {name: 'p256'},\n  'P-384': {name: 'p384'},\n  'P-521': {name: 'p521'}\n};\n\nexport class OpenPGP extends Suite {\n\n  /**\n   * Generated OpenPGP Key Object with given key params.\n   * @param userIds {Array}\n   * @param passphrase {string}\n   * @param params {Object}\n   * @return {Promise<*>}\n   */\n  static async generateKey({userIds=config.openpgp.defaultUser, passphrase=null, params}) {\n    const openpgp = getOpenPgp();\n\n    let options;\n    switch (params.type) {\n    case 'rsa':\n      options = {\n        userIds,       // multiple user IDs\n        numBits: params.modulusLength,// RSA key size\n        passphrase,  // protects the private key\n        keyExpirationTime: params.keyExpirationTime\n      };\n      break;\n    case 'ec':\n      options = {\n        userIds,       // multiple user IDs\n        curve: curveList[params.curve].name,  // applied the naming rule of jscu\n        passphrase,  // protects the private key\n        keyExpirationTime: params.keyExpirationTime\n      };\n      break;\n    case 'session':\n      options = {\n        length: params.length\n      };\n      break;\n    default:\n      throw new Error('GPGUnsupportedAlgorithm');\n    }\n\n    if (params.type === 'rsa' || params.type === 'ec') {\n      const kp = await openpgp.generateKey(options);\n      let keyId = kp.key.getKeys().map((k) => utilKeyId.fromOpenPgpKey(k));\n      if (keyId.length === 1) keyId = keyId[0];\n\n      return {\n        publicKey: kp.key.toPublic(),\n        privateKey: kp.key,\n        keyId  //kp.key.getKeyIds().map( (bid) => bid.toHex())\n      };\n    }\n    else if (params.type === 'session') {\n      const rawKey = await openpgp.crypto.random.getRandomBytes(options.length);\n      const keyId = await utilKeyId.fromRawKey(rawKey);\n      return {key: rawKey, keyId};\n    }\n  }\n\n  static async importKey(type, key, passphrase){\n    const openpgp = getOpenPgp();\n\n    const read = (type === 'pem')\n      ? await openpgp.key.readArmored(key)\n      : await openpgp.key.read(key);\n\n    if(read.err) throw new Error(`InvalidOpenPGPKeyFormat: ${read.err}`);\n\n    const keyArray = await Promise.all(read.keys.map(async (keyObject) => {\n      if (keyObject.isPrivate() && keyObject.primaryKey.isEncrypted) {\n        await keyObject.decrypt(passphrase);\n      }\n      return keyObject;\n    }));\n\n    return (keyArray.length > 1) ? keyArray : keyArray[0];\n  }\n\n  /**\n   * returns {message: { Message, suite }, signature: { Signature, suite }}\n   * if encryption is done simultaneously with signing, no signature id is given because of privacy reason (issuer hiding)\n   * @param message\n   * @param keys\n   * @param options\n   * @param output\n   * @return {Promise<*>}\n   */\n  static async encrypt({message, keys, options={}}){\n    const openpgp = getOpenPgp();\n\n    // check options\n    if(options.compression) options.compression = openpgp.enums.compression[options.compression];\n    options.armor = false; // armor must be false to get key ids after encryption.\n\n    // convert message\n    const msgObj = openpgp.message.fromBinary(message.binary);\n\n    // check signing key format to do signing simultaneously with encryption\n    let signingKeys;\n    if(typeof keys.privateKeys !== 'undefined'\n      && keys.privateKeys instanceof Array\n      && keys.privateKeys[0] instanceof openpgp.key.Key) signingKeys = keys.privateKeys;\n\n    // encryption\n    let encrypted;\n    let encryptedObject;\n    if(keys.publicKeys){ // public key encryption\n      const opt = {\n        message: msgObj,\n        publicKeys: keys.publicKeys, // for encryption\n        privateKeys: signingKeys, // for signing (optional)\n        format: 'binary'\n      };\n      encrypted = await openpgp.encrypt(Object.assign(opt, options));\n\n      // construct an encrypted message object\n      const internalHexKeyIds = encrypted.message.getEncryptionKeyIds().map( (id) => id.toHex());\n      const externalKeyIds = [];\n      keys.publicKeys.map( (x) => x.getKeys().map( (k) => { externalKeyIds.push(utilKeyId.fromOpenPgpKey(k));} ) );\n      const encryptionKeyId = externalKeyIds.filter( (fp) => internalHexKeyIds.indexOf(fp.toHex().slice(0, 16)) >= 0);\n      const encryptedMessage = [\n        createRawEncryptedMessage(encrypted.message.packets.write(), utilKeyId.createKeyIdList(encryptionKeyId), {})\n      ];\n      encryptedObject = {message: createEncryptedMessage('openpgp', 'public_key_encrypt', encryptedMessage, {})};\n    }\n    else if (keys.sessionKey) { // symmetric key encryption\n      const opt = {\n        message: msgObj,\n        sessionKey: {data: keys.sessionKey, algorithm: options.algorithm}, // for encryption\n        privateKeys: signingKeys, // for signing (optional)\n        format: 'binary'\n      };\n      encrypted = await openpgp.encrypt(Object.assign(opt, options));\n\n      // construct an encrypted message object\n      const encryptedMessage = [\n        createRawEncryptedMessage(encrypted.message.packets.write(), await utilKeyId.fromRawKey(keys.sessionKey), {})\n      ];\n      encryptedObject = {message: createEncryptedMessage(\n        'openpgp', 'session_key_encrypt', encryptedMessage, {algorithm: options.algorithm}\n      )};\n    }\n    else throw new Error('InvalidEncryptionKey');\n\n    let signatureObj = {};\n    if (keys.privateKeys && encrypted.signature) { // if detached is true\n      const signatureObjectList = OpenPGP._listFromOpenPgpSig(encrypted.signature.packets, signingKeys);\n      signatureObj = {signature: createSignature('openpgp', 'public_key_sign', signatureObjectList, {})};\n    }\n\n    return Object.assign(encryptedObject, signatureObj);\n  }\n\n\n  /**\n   * Decrypt OpenPGP encrypted message\n   * @param encrypted\n   * @param keys\n   * @param options\n   * @return {Promise<*>}\n   */\n  static async decrypt({ encrypted, keys, options = {} }){\n    const openpgp = getOpenPgp();\n\n    const message = await openpgp.message.read(encrypted.message.message[0].toBuffer(), false);\n    const params = Object.assign({ message, publicKeys: keys.publicKeys, format: 'binary' }, options);\n\n    if(encrypted.message.keyType === 'public_key_encrypt'){\n      Object.assign(params, {privateKeys: keys.privateKeys});\n    }\n    else if (encrypted.message.keyType === 'session_key_encrypt'){\n      Object.assign(params, {sessionKeys: [ {data: keys.sessionKey, algorithm: options.algorithm} ]});\n    }\n    else throw new Error('UnknownKeyType');\n\n    const decrypted = await openpgp.decrypt(params);\n    decrypted.data = new Uint8Array(decrypted.data);\n\n    if (decrypted.signatures instanceof Array){\n      decrypted.signatures = decrypted.signatures.map( (sig) => {\n        const short = sig.keyid.toHex();\n        const long = sig.signature.packets.map( (s) => new Uint8Array(s.issuerFingerprint));\n        const filtered = long.filter((l) => short === jseu.encoder.arrayBufferToHexString(l).slice(0, 16) );\n        if (filtered.length === 0) throw new Error('SomethingWrongInOpenPGPSignature');\n        return {keyId: utilKeyId.createKeyId(filtered[0]), valid: sig.valid};\n      });\n    }\n\n    return decrypted;\n  }\n\n  /**\n   * Returns detached signature\n   * @param message\n   * @param keys\n   * @param options\n   * @param output\n   * @return {Promise<*>}\n   */\n  static async sign({message, keys, options={}}){\n    const openpgp = getOpenPgp();\n\n    // check options\n    options.detached = true; // this must be always true for individual signature\n    options.armor = false; // this must be always false to get key ids\n\n    const msgObj = openpgp.message.fromBinary(message.binary);\n\n    if(!keys.privateKeys) throw new Error('SigningKeyRequired');\n    const opt = {\n      message: msgObj,\n      privateKeys: keys.privateKeys // for signing (optional)\n    };\n    const signature = await openpgp.sign(Object.assign(opt, options));\n    const signatureObjectList = OpenPGP._listFromOpenPgpSig(signature.signature.packets, keys.privateKeys);\n    return {signature: createSignature('openpgp', 'public_key_sign', signatureObjectList, {})};\n  }\n\n  /**\n   * Returns detached signature with verification result\n   * @param message\n   * @param signature\n   * @param keys\n   * @param options\n   * @return {Promise<*>}\n   */\n  static async verify({message, signature, keys, options}){\n    const openpgp = getOpenPgp();\n\n    if(!keys.publicKeys) throw new Error('VerificationKeyRequired');\n    const list = OpenPGP._ListToOpenPgpSig(signature.signatures, keys.publicKeys);\n    const msgObj = openpgp.message.fromBinary(message.binary);\n\n    const verified = await Promise.all(list.signatureObjects.map( async (sigKey) => {\n      const msg = msgObj.unwrapCompressed();\n      const literalDataList = msg.packets.filterByTag(openpgp.enums.packet.literal);\n      const signatureList = [sigKey.openpgpSignature];\n      const valid = await openpgp.message.createVerificationObjects(signatureList, literalDataList, [sigKey.publicKey], new Date());\n      return {keyId: sigKey.signature.keyId, valid: await valid[0].verified};\n    }));\n\n    return verified.concat(list.unverified);\n  }\n\n  static _listFromOpenPgpSig (signatures, keys) {\n    if (!(signatures instanceof Array)) throw new Error('InvalidSignatureList');\n\n    const externalKeyIds = [];\n    keys.map( (x) => x.getKeys().map( (k) => { externalKeyIds.push(utilKeyId.fromOpenPgpKey(k));} ) );\n\n    const signatureObjects = [];\n    externalKeyIds.map( (fp) => {\n      const correspondingSig = signatures.filter( (sig) => sig.issuerKeyId.toHex() === fp.toHex().slice(0,16));\n      correspondingSig.map((sig) => {\n        signatureObjects.push(createRawSignature(sig.write(), fp));\n      });\n    });\n\n    return signatureObjects;\n  }\n\n  static _ListToOpenPgpSig (signatures, keys) {\n    if (!(signatures instanceof Array)) throw new Error('InvalidSignatureList');\n\n    const openpgp = getOpenPgp();\n\n    const openpgpObjects = signatures.map((sig) => {\n      if (!(sig instanceof RawSignature)) throw new Error('NotRawSignatureObject');\n      const obj = new openpgp.packet.Signature();\n      obj.read(sig.toBuffer(), 0, -1);\n      return {openpgpSignature: obj, signature: sig};\n    });\n\n    const externalKey = [];\n    keys.map( (x) => x.getKeys().map( (k) => { externalKey.push({publicKey: k, keyId: utilKeyId.fromOpenPgpKey(k)});} ) );\n\n    const signatureObjects = [];\n    externalKey.map( (fp) => {\n      const correspondingSig = openpgpObjects.filter( (sig) => sig.openpgpSignature.issuerKeyId.toHex() === fp.keyId.toHex().slice(0,16));\n      correspondingSig.map((sig) => {\n        signatureObjects.push(Object.assign({publicKey: fp.publicKey}, sig));\n      });\n    });\n    const unverified = [];\n    const idArray = signatureObjects.map( (x) => x.openpgpSignature.issuerKeyId.toHex());\n    openpgpObjects.map( (sig) => {\n      if(idArray.indexOf(sig.openpgpSignature.issuerKeyId.toHex().slice(0,16)) < 0){\n        unverified.push({keyId: utilKeyId.createKeyId(sig.openpgpSignature.issuerFingerprint), valid: undefined});\n      }\n    });\n\n    return {signatureObjects, unverified};\n  }\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/suite_openpgp.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "name": "curveList",
    "memberof": "src/suite_openpgp.js",
    "static": true,
    "longname": "src/suite_openpgp.js~curveList",
    "access": "public",
    "export": false,
    "importPath": "crypto-cascade/src/suite_openpgp.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "{\"P-256\": *, \"P-384\": *, \"P-521\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 209,
    "kind": "class",
    "name": "OpenPGP",
    "memberof": "src/suite_openpgp.js",
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/suite_openpgp.js",
    "importStyle": "{OpenPGP}",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "interface": false,
    "extends": [
      "src/suite.js~Suite"
    ]
  },
  {
    "__docId__": 210,
    "kind": "method",
    "name": "generateKey",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP.generateKey",
    "access": "public",
    "description": "Generated OpenPGP Key Object with given key params.",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "userIds",
        "description": "{Array}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "passphrase",
        "description": "{string}"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "{Object}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 211,
    "kind": "method",
    "name": "importKey",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP.importKey",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "key",
        "types": [
          "*"
        ]
      },
      {
        "name": "passphrase",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "method",
    "name": "encrypt",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP.encrypt",
    "access": "public",
    "description": "returns {message: { Message, suite }, signature: { Signature, suite }}\nif encryption is done simultaneously with signing, no signature id is given because of privacy reason (issuer hiding)",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 213,
    "kind": "method",
    "name": "decrypt",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP.decrypt",
    "access": "public",
    "description": "Decrypt OpenPGP encrypted message",
    "lineNumber": 179,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "encrypted",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 214,
    "kind": "method",
    "name": "sign",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP.sign",
    "access": "public",
    "description": "Returns detached signature",
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "output",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 215,
    "kind": "method",
    "name": "verify",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP.verify",
    "access": "public",
    "description": "Returns detached signature with verification result",
    "lineNumber": 244,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "message",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "signature",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "keys",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<*>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 216,
    "kind": "method",
    "name": "_listFromOpenPgpSig",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP._listFromOpenPgpSig",
    "access": "private",
    "description": null,
    "lineNumber": 262,
    "undocument": true,
    "params": [
      {
        "name": "signatures",
        "types": [
          "*"
        ]
      },
      {
        "name": "keys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "method",
    "name": "_ListToOpenPgpSig",
    "memberof": "src/suite_openpgp.js~OpenPGP",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/suite_openpgp.js~OpenPGP._ListToOpenPgpSig",
    "access": "private",
    "description": null,
    "lineNumber": 279,
    "undocument": true,
    "params": [
      {
        "name": "signatures",
        "types": [
          "*"
        ]
      },
      {
        "name": "keys",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"signatureObjects\": *, \"unverified\": *}"
      ]
    }
  },
  {
    "__docId__": 218,
    "kind": "file",
    "name": "src/util.js",
    "content": "/**\n * utils.js\n */\n\nimport params from './config.js';\n\nexport function getJscu() {\n  let jscu;\n  if (typeof window !== 'undefined' && typeof window.jscu !== 'undefined'){\n    jscu = window.jscu;\n  }\n  else{\n    try {\n      jscu = require('js-crypto-utils');\n    } catch(e) {\n      throw new Error(`FailedToLoadJSCU: ${e.message}`);\n    } // work around\n  }\n  return jscu;\n}\n\nexport function getOpenPgp(){\n  // load openpgp\n  let openpgp;\n  let workerPath;\n  if(typeof window !== 'undefined' && typeof window.openpgp !== 'undefined') {\n    openpgp = window.openpgp;\n    workerPath = params.openpgp.workerPathWeb;\n  }\n  else {\n    openpgp = require('openpgp');\n    workerPath = params.openpgp.workerPathNode;\n    // const path = require('path');\n    // workerPath = path.join(path.resolve(), openpgpDefault.WORKER_PATH);\n  }\n\n  // initialize openpgp\n  try {\n    openpgp.initWorker({path: workerPath}); // set the relative web worker path\n  } catch(e) {\n    console.error(e.message);\n  }\n  openpgp.config.aead_protect = true; // activate fast AEAD mode (not yet OpenPGP standard)\n  openpgp.config.aead_mode = openpgp.enums.aead.eax; // Default, native AES-EAX mode (AEAD)\n  openpgp.config.prefer_hash_algorithm = openpgp.enums.hash.sha512; // use SHA512 (default SHA256)\n  openpgp.config.encryption_cipher = openpgp.enums.symmetric.aes256; // use AES256\n  openpgp.config.compression = openpgp.enums.compression.zlib; // compression prior to encrypt with zlib\n  openpgp.config.integrity_protect = true;\n  openpgp.config.rsa_blinding = true;\n  openpgp.config.show_version = false;\n  openpgp.config.show_comment = false;\n\n  return openpgp;\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/src/util.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 219,
    "kind": "function",
    "name": "getJscu",
    "memberof": "src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/util.js~getJscu",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/util.js",
    "importStyle": "{getJscu}",
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 220,
    "kind": "function",
    "name": "getOpenPgp",
    "memberof": "src/util.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/util.js~getOpenPgp",
    "access": "public",
    "export": true,
    "importPath": "crypto-cascade/src/util.js",
    "importStyle": "{getOpenPgp}",
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "kind": "index",
    "content": "Cascade - Encryption and signing library for x-brid encryption via several cryptographic suites.\n--\n[![npm version](https://badge.fury.io/js/crypto-cascade.svg)](https://badge.fury.io/js/crypto-cascade)\n[![CircleCI](https://circleci.com/gh/junkurihara/cascade.svg?style=svg)](https://circleci.com/gh/junkurihara/cascade)\n[![Coverage Status](https://coveralls.io/repos/github/junkurihara/cascade/badge.svg?branch=develop)](https://coveralls.io/github/junkurihara/cascade?branch=develop)\n[![Dependencies](https://david-dm.org/junkurihara/cascade.svg)](https://david-dm.org/junkurihara/cascade)\n[![Maintainability](https://api.codeclimate.com/v1/badges/ebead374220cd81a02b9/maintainability)](https://codeclimate.com/github/junkurihara/cascade/maintainability)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n> **WARNING**: At this time this solution should be considered suitable for research and experimentation, further code and security review is needed before utilization in a production application.\n\n# Introduction and Overview\n\nConsidering existing cryptographic libraries and native APIs for JavaScript, as far as we know, fundamental implementations of primitives have been developed separately in multiple environments such as Node.js and various browsers. In order to fill gaps among those different environments, there exist several nice *universal* cryptographic suites that flawlessly work in most of modern JavaScript environments. Here we have defined 'suites' as ones providing encryption, singing and other supplemental functions like OpenPGP library.\n\nHowever, they are still too primitive to realize a bit more modern cryptographic services in JavaScript. In other words, we see that simple encryption and signing provided by those primitives are insufficient to directly satisfy more complex demands, e.g., *revocation of decryption rights* after encryption of data. Considering such situation, the aim of this project called `Cascade` is to provide a flexible cryptographic application library in JavaScript that realizes the **x-brid encryption** and signing by utilizing multiple cryptographic suites. This enables us to, for instance, realize complex structures of access rights to encrypted data, e.g., revocation after encryption as mentioned above.\n\n## X-brid Encryption\n\nHere we shall explain the detailed mechanism of x-brid encryption by illustrating the simplest example instance of **hybrid** encryption, i.e., `x = 2`, which is a well-known cryptosystem in the current security technology. The following is a schematic block diagram of the hybrid encryption.\n\n![Schematic Diagram of Hybrid Encryption](https://raw.github.com/junkurihara/cascade/master/assets/images/hybrid.svg?sanitize=true)\n\nAs we see, this hybrid procedure consists of two steps where the step 1 encrypts the given plaintext message under (one-time) session key in a certain symmetric key encryption, and the step 2 encrypts the previously-used session key under a given public key(s) as a plaintext in a public key encryption. Although this looks somewhat redundant and waste of computing resource, **it has a great advantage in terms of storage usage in the case where we have multiple receivers**, i.e., multiple public keys. Namely, the encrypted message body that is likely big would be common and recycled to all the receivers, and only encrypted session key that should be small is 'personalized' to each receivers.\n\nMoreover, this cryptosystem could yield another merit, which is the revocation after encryption of data. Assume that we first provide receivers the encrypted message body, and recall that at this point, no one can decrypt it. This implies that you can provide 'personalized' encrypted session keys to only authorized person later and freely discard the encrypted session keys, i.e., granting and revoking decryption rights and access rights to the data. We may know that this is a very basic and fundamental concept of *encryption-based access control* that is likely to be a part of well-known digital rights management (DRM).\n\n`Cascade` project can instantiate the above mentioned hybrid encryption by its nature, and it also generalizes this basic 2-step cryptosystem to `x`-step one (`x > 0`), namely, x-brid encryption.\n\n## Cryptographic Functions Employed in X-brid Encryption and Future Extension\n\nWe briefly explained our concept of x-brid encryption by providing a fairly simple hybrid instance as above. As a natural consequence of the generalization by `Cascade`, we can simply increase the value `x` and compose, say, *tri-brid* (`x = 3`) or *tetra-brid* (`x = 4`) encryption by cascading symmetric encryption steps. (We are honestly unsure this technically sounds at this point, but such structures may fit a certain type of application like the relationship of hybrid encryption and DRM.)\n\nOn the other hand, there is another room to generalize the cryptosystem from the viewpoint of *encryption function* at each step of x-brid encryption. The current implementation of `Cascade` can utilize encryption functions of a couple of cryptographic suites, and they supports only basic public key encryption (RSA and elliptic curve cryptosystems) and symmetric key encryption (AES). We mean that as additions to the public/private key pair based cryptosystem, we should plan to supports other types of modern cryptography as suites. In fact, the concept and current implementation can accept more interesting and modern cryptographic primitive functions as a step of x-brid encryption. For instance:\n\n- Broadcast encryption\n- Attribute-based encryption\n- Secret sharing (e.g., split our session key at the final step!)\n\nWe can see that by employing those functions at some steps, new types of cryptographic application could be realized.\n\nWe also mention that a classical broadcast encryption based on tree can be possibly instantiated in the context of x-brid encryption. This is from the following observation. First consider to attach public key encryption to all steps, and assume that the plaintext message at each step is the private key used in the previous step. This composes a tree of multiple layers of private key encapsulation that is the core of tree-based broadcast encryption.\n\n# Supported Crypto Suites\n\nThis library currently supports two cryptographic suites, OpenPGP and js-crypto-utils. We adopted [openpgpjs](https://openpgpjs.org/) as an implementation of OpenPGP. On the other hand, [js-crypto-utils](https://github.com/junkurihara/jscu) is a simple crypto suite for plain implementations of cryptographic functions unlike fully-specified suites like OpenPGP. We should note that js-crypto-utils can be viewed as a integrated wrapper or interfaces of RFC standardized functions that are mostly built-in ones of browsers and Node.js.\n\n* Encryption and decryption:\n  * js-crypto-utils\n    * Public key encryption (ECDH, HKDF and AES256-GCM combination)\n    * Public key encryption (RSA-OAEP)\n    * Session key encryption (AES-GCM)\n  * OpenPGP\n    * Public key encryption (Elliptic curve cryptography)\n    * Public key encryption (RSA)\n    * Session key encryption (AES-EAX)\n* Signing and verification:\n  * js-crypto-utils\n    * RSA-PSS signature (May not work in IE11 and Edge.)\n    * RSASSA-PKCS1-v1_5 signature\n    * ECDSA signature\n  * OpenPGP\n    * RSA signature\n    * ECDSA signature\n* Key generation:\n  * js-crypto-utils\n    * Public and private key pair generation w/ and w/o passphrase in PEM armored format (ECC and RSA)\n    * Session key generation\n  * OpenPGP\n    * Public and private key pair generation w/ and w/o passphrase in OpenPGP armored format (ECC and RSA)\n    * Session key generation\n\n# Installation and Setup\n\n## Installation\n\nAt your project directory, first do either one of the following.\n\n```shell\n$ npm install --save crypto-cascade # from npm\n$ yarn add crypto-cascade # from yarn\n```\n\nThen import the `Cascade` library as follows.\n\n```javascript\nimport cascade from 'crypto-cascade'\n```\n\nOf cource, you can also directly import the source code by cloning this Github repo.\n\n## Finishing up the setup\n\nThe `Cascade` library doesn't internally import cryptographic suites, i.e., `js-crypto-utils` and `openpgpjs` in a static manner, but it loads them in a dynamic manner. In particular, it calls those suites via `require` for `Node.js` and as `window` objects for browsers. This means that **for browsers, both of or either one of `js-crypto-utils` (`jscu.bundle.js`) and `openpgpjs` (`openpgp.js`/`openpgp.min.js`) must be pre-loaded by `<script>` tags in html files**. Also we should note that for `openpgpjs`, the webworker file `openpgp.worker.js`/`openpgp.worker.min.js` is required to be located in the directory where the `openpgp.js`/`openpgp.min.js` exists. For browsers, the default path to `openpgp.worker.js`/`openpgp.worker.min.js` is the root of your url path, and you can change it by directly specifying the location as follows.\n\n```javascript\nimport cascade from 'crypto-cascade';\ncascade.config.openpgp.workerPathWeb = 'path/to/openpgp.worker.min.js';\n```\n\n# Usage\n\nHere we give some basic example of usecases of `Cascade`. This section is organized as follows. First, we explain how to generate keys in `Cascade`. Then as a function employed at each step of x-brid encryption, we describe a very basic *single* encryption and signing operations in `Cascade`. This can be also viewed as the case where `x = 1`. After these warmp-ups, we finally show how to employ the x-brid encryption in `Cascade`. We should really note that this is just an example and the source/test codes and JSDoc is useful to understand the detailed mechanism and usage of `Cascade`.\n\n## Key generation\n\n`Cascade` provides a basic function to generate PEM-formatted and OpenPGP-armored public private key pairs. The following example describes an example to generate PEM-formatted public and private keys of elliptic curve cryptography using `js-crypto-utils`.\n\n```javascript\nconst keyParam = {\n  suite: 'jscu', // use 'js-crypto-utils'\n  keyParams: { type: 'ec', curve: 'P-256' }\n};\nconst keyPair = await cascade.generateKey(keyParam);\nconst publicKeyPEM = keyPair.publicKey.keyString; // EC public key in PEM format\nconst privateKeyPEM = keyPair.privateKey.keyString; // EC private key in PEM format\n```\n\nHere we should note that for the key generation using `js-crypto-utils`, the generated public key is encoded as `SubjectPublicKeyInfo` specified as a part of X.509 public key certificate ([RFC5280](https://tools.ietf.org/html/rfc5280)). On the other hand, the generated private key is encoded as `PrivateKeyInfo`/`OneAsymmetricKey` defined in PKCS#8 ([RFC5958](https://tools.ietf.org/html/rfc5958)). Hence the private key can be encrypted with a passphrase just by passing API the passphrase string as given below.\n\n```javascript\nconst keyParam = {\n  suite: 'jscu',\n  keyParams: { type: 'ec', curve: 'P-256' },\n  passphrase: 'secret passphrase'\n};\nconst keyPair = await cascade.generateKey(keyParam);\n```\n\nThen, the protected private key is encoded as `EncryptedPrivateKeyInfo`.\n\nNote that in addition to `jscu` as `keyParam.suite`, `openpgp` is also available. The key generation API can generate not only EC public and private key strings but also RSA ones and session keys, where generated session keys are just random bytes given in `Uint8Array` unlike formatted strings of public and private keys.\n\n## Basic encryption simultaneously with signing\n\nThe following example describes how to simply encrypt a message in `Uint8Array` (`String` is also accepted) simultaneously with signing on the given plaintext message in `Cascade`. Since the cascaded encryption, i.e., x-brid encryption, will be employed by chaining this basic encryption and decryption function, we shall firstly explain this basic function and its usage in a step-by-step manner.\n\nFirst of all, we need to import keys to be used, and obtain `Keys` object that will be used to encrypt and decrypt in `Cascade`.\n\n```javascript\nconst encryptionKeys = {\n  publicKeys: [ keys.publicKey.keyString ],\n  privateKeyPassSets:[ { privateKey: keys.privateKey.keyString, passphrase: '' } ] // for Signing\n};\n\n// import encryption key strings\nconst encryptionKeyImported = await cascade.importKeys(\n  'string',\n  {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['encrypt', 'sign']}\n);\n```\n\nThe configuration object for encryption is also required like the following form that must be matched with the type of given encryption and signing keys imported. The following is an example for the case where the given public and private keys are PEM-formatted EC keys, i.e., ECDH+HKDF public key encryption and ECDSA signing, via `js-crypto-utils` (as referred to as `jscu` in the code block).\n\n```javascript\n// Encryption and signing configuration\nconst encryptionConfig = {\n  encrypt: {\n    suite: 'jscu',\n    options: {\n      // HKDF with SHA-256 is employed on the master secret derived from ECDH.\n      hash: 'SHA-256',\n      info: '',\n      keyLength: 32,\n      // The session key HKDF derives is used to encrypt the message via AES-GCM.\n      encrypt: 'AES-GCM'\n    }\n  },\n  sign: {\n    suite: 'jscu',\n    // Signature is required and computed simultaneously with encryption.\n    required: true,\n    options: {\n      hash: 'SHA-256'\n    }\n  }\n};\n```\n\nWith the imported encryption/signing keys and encryption config, the encryption API `cascade.encrypt` employs a single-phase encryption with signing, and it returns an object consisting of `message` and `signature` sub-objects. Those sub-objects are able to be respectively serialized with their instance method `serialize()`.\n\n```javascript\n// encrypt\nconst encryptionResult = await cascade.encrypt({\n  message: messageSomeHow, // in Uint8Array or String\n  keys: encryptionKeyImported,\n  config: encryptionConfig\n});\n\n// serialize\nconst serializedEncrypted = encryptionResult.message.serialize();\nconst serializedSignature = encryptionResult.signature.serialize();\n```\n\nSerialized objects must be de-serialized, i.e., ones in object forms, for decryption in `Cascade`. Serialized encrypted message objects and signature objects can be de-serialized with `cascade.importEncryptedBuffer` and `cascade.importSignatureBuffer` functions and encrypted message and signature objects are obtained.\n\n```javascript\n// de-serialize\nconst deserializedEncrypted = cascade.importEncryptedBuffer(serializedEncrypted);\nconst deserializedSignature = cascade.importSignatureBuffer(serializedSignature);\n```\n\n Much like basic encryption, the decryption and verification key strings must be imported and the `Keys` object is required to decrypt de-serialized message objects.\n\n```javascript\nconst decryptionKeys = {\n  privateKeyPassSets:[ { privateKey: keys.privateKey.keyString, passphrase: '' } ],\n  publicKeys: [ keys.publicKey.keyString ] // for verification\n};\n\n// import decryption key strings\nconst decryptionKeyImported = await cascade.importKeys(\n  'string',\n  {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['decrypt', 'verify']}\n);\n```\n\n By putting de-serialized message and signature objects with imported decryption keys as given above, the `Cascade` API `cascade.decrypt` returns a decrypted data and the result of signature verification.\n\n```javascript\n// decrypt and verify\nconst decryptionResult = await cascade.decrypt({\n  data: { message: deserializedEncrypted, signature: deserializedSignature },\n  keys: decryptionKeyImported\n});\n```\n\nThat's all the *basic* encryption and decryption steps, and the cascaded encryption/decryption in `Cascade` are composed of multiple basic ones that chained sequentially. Next section will briefly explain this step with some exemplary operations.\n\n## Cascaded x-brid encryption with signing\n\nHere we describe how to employ cascaded x-brid encryption simultaneously with signing by showing a simple example.\n\nAll we need to prepare for the cascaded x-brid encryption/decryption is exactly similar to the basic encryption described in the previous section. One main difference from basic ones is that we have to define an **encryption procedure** given as an array of encryption configuration objects. The following is an sample encryption procedure that will be used in this section.\n\n```javascript\nconst encryptionProcedure = [\n  { // step 1\n    encrypt: {\n      suite: 'jscu',\n      onetimeKey: {keyParams: {type: 'session', length: 32}}, options: {name: 'AES-GCM'}\n    },\n    sign: { required: true }\n  },\n  { // step 2\n    encrypt: {\n      suite: 'jscu', options: { hash: 'SHA-256', info: '', keyLength: 32, encrypt: 'AES-GCM' }\n    },\n    sign: { suite: 'jscu', required: true, options: { hash: 'SHA-256' } }\n  }\n];\n```\n\nThe above example describes a procedure of **hybrid encryption** where the given message is first encrypted under a one-time session key generated internally at `Cascade` (step 1), and the session key is then encrypted under the externally given public key (step 2). We can see that the `encrypt.onetimeKey` specifies the key parameters generated at the step 1, and that the step 2 does not require the entry since public key(s) are given externally. In terms of signatures, the signing parameters and keys given the final step, i.e., step 2, will be applied all the other steps if `sign.required = true`.\n\nAfter setting up an encryption procedure, we then obtain a `Keys` object by importing key strings in an exactly same manner as the basic encryption given above. This `Keys` object must be matched the parameters of the final step in the given encryption procedure. We then instantiate a `Cascade` object with the `Keys` object and the given encryption procedure.\n\n```javascript\nconst encryptionKeys = {\n  publicKeys: [ keys.publicKey.keyString ], // for encryption\n  privateKeyPassSets: [ { privateKey: keys.privateKey.keyString, passphrase: '' } ] // for Signing\n};\n\n// import encryption keys\nconst encryptionKeyImported = await cascade.importKeys(\n  'string',\n  {\n    keys: encryptionKeys,\n    suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'},\n    mode: ['encrypt', 'sign']\n  }\n);\n\n// instantiate encryption process\nconst eProcess = await cascade.createEncryptionCascade({\n  keys: encryptionKeyImported,\n  procedure: encryptionProcedure\n});\n```\n\nNow all the encryption setup has done and we can encrypt a message in `Uint8Array` (or `string`) via `encrypt` method of the `Cascade` object. The ciphertext is given as an `EncryptedMessage` object, and the object can be viewed as an array in which each element exactly corresponds to each step of the encryption procedure. Its serialized data can be obtained through `serialize` method, and conversely, we can de-serialize the serialized data through `importCascadeBuffer` function.\n\n```javascript\n// encrypt\nconst encrypted = await eProcess.encrypt(message);\n\n// serialize\nconst serialized = encrypted.serialize();\n\n// de-serialize\nconst deserialized = cascade.importCascadedBuffer(serialized);\n```\n\nDecryption operation is exactly inverse of the above encryption operation. First we must obtain a `Keys` object by importing decryption and verification keys, and instantiate the decryption `Cascade` object to setup the decryption process by the obtained `EncryptedMessage` object. Then, the plaintext message is finally obtained through `decrypt` method.\n\n```javascript\nconst decryptionKeys = {\n  privateKeyPassSets:[ { privateKey: keys.privateKey.keyString, passphrase: '' } ], // for decryption\n  publicKeys: [ keys.publicKey.keyString ] // for verification\n};\n\n// import decryption keys\nconst decryptionKeyImported = await cascade.importKeys(\n  'string',\n  {\n    keys: decryptionKeys,\n    suite: { encrypt_decrypt: 'jscu', sign_verify: 'jscu' },\n    mode: ['decrypt', 'verify']\n  }\n);\n\n// instantiate decryption process\nconst dProcess = await cascade.createDecryptionCascade({\n  keys: decryptionKeyImported,\n  encrypted: deserialized\n});\n\n// decrypt\nconst decrypted = await dProcess.decrypt();\n```\n\n## Drop and extract a part of ciphertext\n\nWe can also **drop and extract** a part of ciphertext, namely some elements of the array `EncryptedMessage`. This enables us to control access rights of users who received the ciphertext by giving them the extracted part separately.\n\n```javascript\nconst idx = 0; // 0 to length-1 of encryption procedure\nconst extracted = encrypted.extract(idx); // drop and extract the indicated part from EncryptedMessage object\n\n// still serializable after extraction\nconst serialized = encrypted.serialize();\n\n// extracted part is an array where each element is serializable as well\nconst serializedExtracted = extracted.map( (obj) => obj.serialize() );\n\n// de-serialize\nconst deserialized = cascade.importCascadedBuffer(serialized);\n\n// de-serialize each extracted part.\nconst deserializedExtracted = cascade.importRawEncryptedBufferList(serializedExtracted);\n\n// recover original EncryptedMessage object]\ndeserialized.insert(idx, deserializedExtracted);\n```\n\n# Note\n\nAt this point, limitations of `Cascade` are basically from those of [js-crypto-utils](https://github.com/junkurihara/jscu) and [openpgpjs](https://openpgpjs.org/). Please refer to their documents first.\n\n# Lisence\n\nLicensed under the MIT license, see `LICENSE` file.",
    "longname": "/Users/jun/ProjectJavaScript/cascade/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"crypto-cascade\",\n  \"version\": \"0.2.4\",\n  \"description\": \"Cascade - An encryption and signing library for x-brid encryption via several crypto suites\",\n  \"author\": \"Jun Kurihara <kurihara@ieee.org>\",\n  \"license\": \"MIT\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"flow:version\": \"npm version --no-git-tag-version\",\n    \"release:start\": \"./node_modules/.bin/can-npm-publish --vorbose && git flow release start v$npm_package_version\",\n    \"release:finish\": \"git flow release finish v$npm_package_version\",\n    \"release:push\": \"git push --all && git push origin v$npm_package_version\",\n    \"docs\": \"esdoc -c .esdoc.json\",\n    \"test\": \"cross-env NODE_ENV=test nyc mocha --recursive $(find test -name '*.spec.js')\",\n    \"test:bundle\": \"npm run webpack && cross-env TEST_ENV=bundle npm run test\",\n    \"karma\": \"cross-env TEST_ENV=source ./node_modules/.bin/karma start\",\n    \"karma:bundle\": \"npm run webpack && cross-env TEST_ENV=bundle ./node_modules/.bin/karma start\",\n    \"karma:window\": \"npm run webpack && cross-env TEST_ENV=window ./node_modules/.bin/karma start\",\n    \"html\": \"npm run html:source && npm run html:bundle && npm run html:window\",\n    \"html:source\": \"cross-env TEST_ENV=source NODE_ENV=html npm run webpack\",\n    \"html:bundle\": \"cross-env TEST_ENV=bundle NODE_ENV=html npm run webpack\",\n    \"html:window\": \"cross-env TEST_ENV=window NODE_ENV=html npm run webpack\",\n    \"webpack\": \"./node_modules/.bin/webpack --optimize-minimize --mode development --config webpack.dev.js\",\n    \"webpack:prod\": \"cross-env NODE_ENV=production ./node_modules/.bin/webpack --optimize-minimize --mode production --config webpack.prod.js\",\n    \"analyze\": \"cross-env NODE_ENV=production ./node_modules/.bin/webpack --mode production --optimize-minimize --json --config webpack.prod.js | webpack-bundle-size-analyzer\",\n    \"build\": \"cross-env NODE_ENV=production ./node_modules/.bin/babel src -d dist/ --keep-file-extension && npm run webpack:prod\"\n  },\n  \"devDependencies\": {\n    \"@babel/cli\": \"7.1.5\",\n    \"@babel/core\": \"7.1.6\",\n    \"@babel/preset-env\": \"7.1.6\",\n    \"@babel/register\": \"7.0.0\",\n    \"babel-eslint\": \"10.0.1\",\n    \"babel-loader\": \"8.0.4\",\n    \"babel-plugin-istanbul\": \"5.1.0\",\n    \"babel-plugin-transform-remove-console\": \"6.9.4\",\n    \"can-npm-publish\": \"1.3.1\",\n    \"chai\": \"4.2.0\",\n    \"cross-env\": \"5.2.0\",\n    \"esdoc\": \"1.1.0\",\n    \"esdoc-standard-plugin\": \"1.0.0\",\n    \"eslint\": \"5.9.0\",\n    \"jsdom\": \"13.0.0\",\n    \"karma\": \"3.1.1\",\n    \"karma-chrome-launcher\": \"2.2.0\",\n    \"karma-cli\": \"1.0.1\",\n    \"karma-coverage\": \"1.1.2\",\n    \"karma-mocha\": \"1.3.0\",\n    \"karma-mocha-reporter\": \"2.2.5\",\n    \"karma-webpack\": \"3.0.5\",\n    \"mocha\": \"5.2.0\",\n    \"mocha-sinon\": \"2.1.0\",\n    \"nyc\": \"13.1.0\",\n    \"webpack\": \"4.26.1\",\n    \"webpack-cli\": \"3.1.2\",\n    \"webpack-common-shake\": \"2.1.0\",\n    \"webpack-merge\": \"4.1.4\"\n  },\n  \"dependencies\": {\n    \"@babel/plugin-transform-runtime\": \"^7.1.0\",\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/runtime\": \"^7.1.5\",\n    \"js-crypto-utils\": \"^0.14.0\",\n    \"js-encoding-utils\": \"^0.3.0\",\n    \"lodash.clonedeep\": \"^4.5.0\",\n    \"msgpack-lite\": \"^0.1.26\",\n    \"openpgp\": \"^4.2.1\"\n  },\n  \"browser\": {\n    \"openpgp\": false,\n    \"js-crypto-utils\": false\n  }\n}\n",
    "longname": "/Users/jun/ProjectJavaScript/cascade/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  },
  {
    "__docId__": 221,
    "kind": "testFile",
    "name": "test/api.basic.encrypt-sign-session.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: session key encryption/decryption with simultaneous signing/verification`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: symmetric key encryption and public key signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          sessionKey: param.Keys.sessionKey,\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.jscuSessionEncryptConf, sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          sessionKey: param.Keys.sessionKey,\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n  \n  it('openpgp: symmetric key encryption and public key signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          sessionKey: param.Keys.sessionKey,\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.openpgpgSessionEncryptConf, sign: param.openpgpSignConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          sessionKey: param.Keys.sessionKey,\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.encrypt-sign-session.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 222,
    "kind": "test",
    "name": "describe0",
    "testId": 0,
    "memberof": "test/api.basic.encrypt-sign-session.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.encrypt-sign-session.spec.js~describe0",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 223,
    "kind": "test",
    "name": "it1",
    "testId": 1,
    "memberof": "test/api.basic.encrypt-sign-session.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign-session.spec.js~describe0.it1",
    "access": null,
    "description": "jscu: symmetric key encryption and public key signing test",
    "lineNumber": 25
  },
  {
    "__docId__": 224,
    "kind": "test",
    "name": "it2",
    "testId": 2,
    "memberof": "test/api.basic.encrypt-sign-session.spec.js~describe0",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign-session.spec.js~describe0.it2",
    "access": null,
    "description": "openpgp: symmetric key encryption and public key signing test",
    "lineNumber": 53
  },
  {
    "__docId__": 225,
    "kind": "testFile",
    "name": "test/api.basic.encrypt-sign.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: single public key encryption/decryption with simultaneous signing/verification`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: EC/RSA encryption and signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConf(paramObject, idx), sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n  it('jscu: EC/RSA encryption and signing test with ephemeral ECDH keys',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConfEphemeral(paramObject), sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n  \n  it('openpgp: RSA/EC encryption and signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.openpgpEncryptConf, sign: param.openpgpSignConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n\n  it('mix1 (encrypt: openpgp, sign: jscu): RSA/EC encryption and signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey:param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.openpgpEncryptConf, sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'jscu'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'jscu'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n\n  it('mix2 (encrypt: jscu, sign: openpgp): RSA/EC encryption and sining test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConf(paramObject, idx), sign: param.openpgpSignConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'openpgp'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'openpgp'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n  it('mix2 (encrypt: jscu, sign: openpgp): RSA/EC encryption and sining test with ephemeral ECDH keys',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConfEphemeral(paramObject), sign: param.openpgpSignConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'openpgp'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'openpgp'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.encrypt-sign.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 226,
    "kind": "test",
    "name": "describe3",
    "testId": 3,
    "memberof": "test/api.basic.encrypt-sign.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 227,
    "kind": "test",
    "name": "it4",
    "testId": 4,
    "memberof": "test/api.basic.encrypt-sign.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3.it4",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing test",
    "lineNumber": 25
  },
  {
    "__docId__": 228,
    "kind": "test",
    "name": "it5",
    "testId": 5,
    "memberof": "test/api.basic.encrypt-sign.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3.it5",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing test with ephemeral ECDH keys",
    "lineNumber": 53
  },
  {
    "__docId__": 229,
    "kind": "test",
    "name": "it6",
    "testId": 6,
    "memberof": "test/api.basic.encrypt-sign.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3.it6",
    "access": null,
    "description": "openpgp: RSA/EC encryption and signing test",
    "lineNumber": 81
  },
  {
    "__docId__": 230,
    "kind": "test",
    "name": "it7",
    "testId": 7,
    "memberof": "test/api.basic.encrypt-sign.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3.it7",
    "access": null,
    "description": "mix1 (encrypt: openpgp, sign: jscu): RSA/EC encryption and signing test",
    "lineNumber": 110
  },
  {
    "__docId__": 231,
    "kind": "test",
    "name": "it8",
    "testId": 8,
    "memberof": "test/api.basic.encrypt-sign.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3.it8",
    "access": null,
    "description": "mix2 (encrypt: jscu, sign: openpgp): RSA/EC encryption and sining test",
    "lineNumber": 139
  },
  {
    "__docId__": 232,
    "kind": "test",
    "name": "it9",
    "testId": 9,
    "memberof": "test/api.basic.encrypt-sign.spec.js~describe3",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt-sign.spec.js~describe3.it9",
    "access": null,
    "description": "mix2 (encrypt: jscu, sign: openpgp): RSA/EC encryption and sining test with ephemeral ECDH keys",
    "lineNumber": 167
  },
  {
    "__docId__": 233,
    "kind": "testFile",
    "name": "test/api.basic.encrypt.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: public key encryption/decryption`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: EC/RSA encryption test', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ],\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConf(paramObject, idx) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu' }, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n\n  it('jscu: EC/RSA encryption test with ephemeral ECDH key', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ],\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConfEphemeral(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu' }, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n  \n  it('openpgp: RSA/EC encryption test', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ],\n        };\n        const encryptConfig = { encrypt: param.openpgpEncryptConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp'}, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n\n  it('jscu: EC/RSA encryption test with multiple public keys', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [\n            param.Keys[paramObject.name][idx].publicKey.keyString,\n            param.Keys[paramObject.name][idx].publicKey.keyString\n          ],\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConf(paramObject, idx) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu' }, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[\n            { privateKey: param.Keys[paramObject.name][0].privateKey.keyString, passphrase: '' }, // this sometimes failed\n            { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' }\n          ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n\n  it('jscu: EC/RSA encryption test with multiple public keys with ephemeral ECDH', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [\n            param.Keys[paramObject.name][idx].publicKey.keyString,\n            param.Keys[paramObject.name][idx].publicKey.keyString\n          ],\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConfEphemeral(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu' }, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          privateKeyPassSets:[\n            { privateKey: param.Keys[paramObject.name][0].privateKey.keyString, passphrase: '' }, // this sometimes failed\n            { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' }\n          ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({ data: encryptionResult, keys: decryptionKeyImported });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.encrypt.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 234,
    "kind": "test",
    "name": "describe10",
    "testId": 10,
    "memberof": "test/api.basic.encrypt.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.encrypt.spec.js~describe10",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 235,
    "kind": "test",
    "name": "it11",
    "testId": 11,
    "memberof": "test/api.basic.encrypt.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt.spec.js~describe10.it11",
    "access": null,
    "description": "jscu: EC/RSA encryption test",
    "lineNumber": 25
  },
  {
    "__docId__": 236,
    "kind": "test",
    "name": "it12",
    "testId": 12,
    "memberof": "test/api.basic.encrypt.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt.spec.js~describe10.it12",
    "access": null,
    "description": "jscu: EC/RSA encryption test with ephemeral ECDH key",
    "lineNumber": 51
  },
  {
    "__docId__": 237,
    "kind": "test",
    "name": "it13",
    "testId": 13,
    "memberof": "test/api.basic.encrypt.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt.spec.js~describe10.it13",
    "access": null,
    "description": "openpgp: RSA/EC encryption test",
    "lineNumber": 77
  },
  {
    "__docId__": 238,
    "kind": "test",
    "name": "it14",
    "testId": 14,
    "memberof": "test/api.basic.encrypt.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt.spec.js~describe10.it14",
    "access": null,
    "description": "jscu: EC/RSA encryption test with multiple public keys",
    "lineNumber": 103
  },
  {
    "__docId__": 239,
    "kind": "test",
    "name": "it15",
    "testId": 15,
    "memberof": "test/api.basic.encrypt.spec.js~describe10",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.encrypt.spec.js~describe10.it15",
    "access": null,
    "description": "jscu: EC/RSA encryption test with multiple public keys with ephemeral ECDH",
    "lineNumber": 135
  },
  {
    "__docId__": 240,
    "kind": "testFile",
    "name": "test/api.basic.keygen.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst core = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\ndescribe(`${env}: public and private key pair generation test`, () => {\n  const curves = [ 'P-256', 'P-384', 'P-521' ];\n  const modulusLength = [ 2048, 4096 ];\n  const userIds = [ 'kurihara@zettant.com' ];\n\n  it('OpenPGP key generation with passphrase', async function () {\n    this.timeout(5000);\n\n    const keyArray = await Promise.all( curves.map ( (curve) => {\n      const keyParam = {suite: 'openpgp', userIds, passphrase: 'omg', keyParams: {type: 'ec', keyExpirationTime: 0, curve}};\n      return core.generateKey(keyParam);\n    }) );\n    // console.log(keyArray);\n    const ok = keyArray.every( (k) => !!k.privateKey.passphrase);\n    expect(ok).to.be.true;\n  });\n\n  it('OpenPGP key generation without passphrase', async function () {\n    this.timeout(5000);\n\n    const baseParam = { type: 'ec', keyExpirationTime: 0 };\n\n    const keyArray = await Promise.all( curves.map ( (curve) => {\n      const keyParam = {suite: 'openpgp', userIds, keyParams: Object.assign(baseParam, {curve})};\n      return core.generateKey(keyParam);\n    }) );\n    // console.log(keyArray);\n    const ng = keyArray.every( (k) => !k.privateKey.passphrase);\n    expect(ng).to.be.true;\n  });\n\n  it('JSCU EC public key pair generation', async function () {\n    this.timeout(5000);\n    let success = true;\n    const keyArray = await Promise.all( curves.map ( (curve) => {\n      const keyParam = {suite: 'jscu', keyParams: {type: 'ec', curve}};\n      return core.generateKey(keyParam);\n    }) ).catch( (e) => {console.error(e.message); success = false; });\n    expect(success).to.be.true;\n    // console.log(keyArray);\n  });\n\n  it('JSCU protected EC public key pair generation', async function () {\n    this.timeout(5000);\n    let success = true;\n    const keyArray = await Promise.all( curves.map ( (curve) => {\n      const keyParam = {suite: 'jscu', keyParams: {type: 'ec', curve}, passphrase: 'omg'};\n      return core.generateKey(keyParam);\n    }) ).catch( (e) => {console.error(e.message); success = false; });\n    expect(success).to.be.true;\n    // console.log(keyArray);\n  });\n\n  it('JSCU RSA public key pair generation', async function () {\n    this.timeout(5000);\n    let success = true;\n    const keyArray = await Promise.all( modulusLength.map ( (ml) => {\n      const keyParam = {suite: 'jscu', keyParams: {type: 'rsa', modulusLength: ml}};\n      return core.generateKey(keyParam);\n    }) ).catch( (e) => {console.error(e.message); success = false; });\n    expect(success).to.be.true;\n    // console.log(keyArray);\n  });\n\n  it('JSCU protected RSA public key pair generation', async function () {\n    this.timeout(5000);\n    let success = true;\n    const keyArray = await Promise.all( modulusLength.map ( (ml) => {\n      const keyParam = {suite: 'jscu', keyParams: {type: 'rsa', modulusLength: ml}, passphrase: 'omg'};\n      return core.generateKey(keyParam);\n    }) ).catch( (e) => {console.error(e.message); success = false; });\n    expect(success).to.be.true;\n    // keyArray.map( (x) => {console.log(x);});\n  });\n\n  it('OpenPGP symmetric session key generation', async function (){\n    this.timeout(5000);\n    const keyParam = {suite: 'openpgp', keyParams: {type: 'session', length: 32}};\n    const key = await core.generateKey(keyParam);\n    expect((key.key instanceof Uint8Array) && (key.key.length === 32)).to.be.true;\n    // console.log(key);\n  });\n\n\n  it('JSCU symmetric session key generation', async function (){\n    this.timeout(5000);\n    const keyParam = {suite: 'jscu', keyParams: {type: 'session', length: 32}};\n    const key = await core.generateKey(keyParam);\n    expect((key.key instanceof Uint8Array) && (key.key.length === 32)).to.be.true;\n    // console.log(key);\n  });\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.keygen.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 241,
    "kind": "test",
    "name": "describe16",
    "testId": 16,
    "memberof": "test/api.basic.keygen.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16",
    "access": null,
    "lineNumber": 10
  },
  {
    "__docId__": 242,
    "kind": "test",
    "name": "it17",
    "testId": 17,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it17",
    "access": null,
    "description": "OpenPGP key generation with passphrase",
    "lineNumber": 15
  },
  {
    "__docId__": 243,
    "kind": "test",
    "name": "it18",
    "testId": 18,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it18",
    "access": null,
    "description": "OpenPGP key generation without passphrase",
    "lineNumber": 27
  },
  {
    "__docId__": 244,
    "kind": "test",
    "name": "it19",
    "testId": 19,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it19",
    "access": null,
    "description": "JSCU EC public key pair generation",
    "lineNumber": 41
  },
  {
    "__docId__": 245,
    "kind": "test",
    "name": "it20",
    "testId": 20,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it20",
    "access": null,
    "description": "JSCU protected EC public key pair generation",
    "lineNumber": 52
  },
  {
    "__docId__": 246,
    "kind": "test",
    "name": "it21",
    "testId": 21,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it21",
    "access": null,
    "description": "JSCU RSA public key pair generation",
    "lineNumber": 63
  },
  {
    "__docId__": 247,
    "kind": "test",
    "name": "it22",
    "testId": 22,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it22",
    "access": null,
    "description": "JSCU protected RSA public key pair generation",
    "lineNumber": 74
  },
  {
    "__docId__": 248,
    "kind": "test",
    "name": "it23",
    "testId": 23,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it23",
    "access": null,
    "description": "OpenPGP symmetric session key generation",
    "lineNumber": 85
  },
  {
    "__docId__": 249,
    "kind": "test",
    "name": "it24",
    "testId": 24,
    "memberof": "test/api.basic.keygen.spec.js~describe16",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.keygen.spec.js~describe16.it24",
    "access": null,
    "description": "JSCU symmetric session key generation",
    "lineNumber": 94
  },
  {
    "__docId__": 250,
    "kind": "testFile",
    "name": "test/api.basic.msgpack.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: message-pack test`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: EC/RSA encryption and signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ],\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConf(paramObject, idx), sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['encrypt', 'sign']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n        const serializedEncrypted = encryptionResult.message.serialize();\n        const serializedSignature = encryptionResult.signature.serialize();\n\n        const deserializedEncrypted = cascade.importEncryptedBuffer(serializedEncrypted);\n        const deserializedSignature = cascade.importSignatureBuffer(serializedSignature);\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu'}, mode: ['decrypt', 'verify']}\n        );\n        const decryptionResult = await cascade.decrypt({\n          data: {message: deserializedEncrypted, signature: deserializedSignature},\n          keys: decryptionKeyImported\n        });\n        expect(decryptionResult.signatures.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n  it('jscu: EC/RSA encryption test with multiple public keys', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [\n            param.Keys[paramObject.name][idx].publicKey.keyString,\n            param.Keys[paramObject.name][idx].publicKey.keyString\n          ],\n        };\n        const encryptConfig = { encrypt: param.jscuEncryptConf(paramObject, idx) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu' }, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n        const serializedEncrypted = encryptionResult.message.serialize();\n\n        const deserializedEncrypted = cascade.importEncryptedBuffer(serializedEncrypted);\n        const decryptionKeys = {\n          privateKeyPassSets:[\n            { privateKey: param.Keys[paramObject.name][0].privateKey.keyString, passphrase: '' }, // this sometimes failed\n            { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' }\n          ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({\n          data: {message: deserializedEncrypted},\n          keys: decryptionKeyImported\n        });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n\n  it('openpgp: RSA/EC encryption test', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ],\n        };\n        const encryptConfig = { encrypt: param.openpgpEncryptConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp'}, mode: ['encrypt']}\n        );\n        const encryptionResult = await cascade.encrypt({ message, keys: encryptionKeyImported, config: encryptConfig});\n        const serializedEncrypted = encryptionResult.message.serialize();\n\n        const deserializedEncrypted = cascade.importEncryptedBuffer(serializedEncrypted);\n        const decryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ],\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp'}, mode: ['decrypt']}\n        );\n        const decryptionResult = await cascade.decrypt({\n          data: {message: deserializedEncrypted}, keys: decryptionKeyImported\n        });\n        expect(decryptionResult.data.toString()===message.toString()).to.be.true;\n      }));\n    }));\n  });\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.msgpack.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 251,
    "kind": "test",
    "name": "describe25",
    "testId": 25,
    "memberof": "test/api.basic.msgpack.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.msgpack.spec.js~describe25",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 252,
    "kind": "test",
    "name": "it26",
    "testId": 26,
    "memberof": "test/api.basic.msgpack.spec.js~describe25",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.msgpack.spec.js~describe25.it26",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing test",
    "lineNumber": 25
  },
  {
    "__docId__": 253,
    "kind": "test",
    "name": "it27",
    "testId": 27,
    "memberof": "test/api.basic.msgpack.spec.js~describe25",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.msgpack.spec.js~describe25.it27",
    "access": null,
    "description": "jscu: EC/RSA encryption test with multiple public keys",
    "lineNumber": 60
  },
  {
    "__docId__": 254,
    "kind": "test",
    "name": "it28",
    "testId": 28,
    "memberof": "test/api.basic.msgpack.spec.js~describe25",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.msgpack.spec.js~describe25.it28",
    "access": null,
    "description": "openpgp: RSA/EC encryption test",
    "lineNumber": 97
  },
  {
    "__docId__": 255,
    "kind": "testFile",
    "name": "test/api.basic.params.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\ndescribe(`${env}: public key signing/verification`, () => {\n\n  let message;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n  });\n\n  const testString = 'test string';\n  it('check if cascade.config can be changed correctly',  async () => {\n    cascade.config.openpgp.workerPathWeb = testString;\n    expect(cascade.config.openpgp.workerPathWeb === testString).to.be.true;\n  });\n\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.params.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 256,
    "kind": "test",
    "name": "describe29",
    "testId": 29,
    "memberof": "test/api.basic.params.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.params.spec.js~describe29",
    "access": null,
    "lineNumber": 10
  },
  {
    "__docId__": 257,
    "kind": "test",
    "name": "it30",
    "testId": 30,
    "memberof": "test/api.basic.params.spec.js~describe29",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.params.spec.js~describe29.it30",
    "access": null,
    "description": "check if cascade.config can be changed correctly",
    "lineNumber": 21
  },
  {
    "__docId__": 258,
    "kind": "testFile",
    "name": "test/api.basic.sign.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: public key signing/verification`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: EC/RSA signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          privateKeyPassSets:[ { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {sign_verify: 'jscu'}, mode: ['sign']}\n        );\n        const encryptionResult = await cascade.sign({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          publicKeys: [ param.Keys[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {sign_verify: 'jscu'}, mode: ['verify']}\n        );\n        const decryptionResult = await cascade.verify({ message, signature: encryptionResult.signature, keys: decryptionKeyImported });\n        expect(decryptionResult.every((s) => s.valid), `failed at ${p}`).to.be.a.true;\n      }));\n    }));\n  });\n  \n  it('openpgp: RSA/EC signing test',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const encryptionKeys = {\n          privateKeyPassSets:[ { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' } ] // for Signing\n        };\n        const encryptConfig = { sign: param.openpgpSignConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {sign_verify: 'openpgp'}, mode: ['sign']}\n        );\n        const encryptionResult = await cascade.sign({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {sign_verify: 'openpgp'}, mode: ['verify']}\n        );\n        const decryptionResult = await cascade.verify({ message, signature: encryptionResult.signature, keys: decryptionKeyImported });\n        expect(decryptionResult.every((s) => s.valid), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n\n  it('jscu: EC/RSA signing test with multiple secret keys',  async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const subidx = (idx===0) ? idx+1 : 0;\n        const encryptionKeys = {\n          privateKeyPassSets:[\n            { privateKey: param.Keys[paramObject.name][subidx].privateKey.keyString, passphrase: '' },\n            { privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: '' }\n          ] // for Signing\n        };\n        const encryptConfig = { sign: param.jscuSignConf(paramObject) };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {sign_verify: 'jscu'}, mode: ['sign']}\n        );\n        const encryptionResult = await cascade.sign({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          publicKeys:[\n            // param.Keys[paramObject.name][0].publicKey.keyString,\n            param.Keys[paramObject.name][idx].publicKey.keyString,\n          ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {sign_verify: 'jscu'}, mode: ['verify']}\n        );\n        const decryptionResult = await cascade.verify({ message, signature: encryptionResult.signature, keys: decryptionKeyImported });\n        expect(decryptionResult.every((s) => (s.valid || s.valid === undefined)), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n  it('openpgp: RSA/EC signing test with multiple secret keys', async function () {\n    this.timeout(50000);\n    await Promise.all(param.paramArray.map( async (paramObject) => {\n      await Promise.all(paramObject.param.map( async (p, idx) => {\n        const subidx = (idx===0) ? idx+1 : 0;\n        const encryptionKeys = {\n          privateKeyPassSets:[\n            { privateKey:param.KeysGPG[paramObject.name][subidx].privateKey.keyString, passphrase: '' },\n            { privateKey:param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: '' }\n          ] // for Signing\n        };\n        const encryptConfig = { sign: param.openpgpSignConf };\n\n        const encryptionKeyImported = await cascade.importKeys(\n          'string', {keys: encryptionKeys, suite: {sign_verify: 'openpgp'}, mode: ['sign']}\n        );\n        const encryptionResult = await cascade.sign({ message, keys: encryptionKeyImported, config: encryptConfig});\n\n        const decryptionKeys = {\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString ] // for verification\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {sign_verify: 'openpgp'}, mode: ['verify']}\n        );\n        const decryptionResult = await cascade.verify({ message, signature: encryptionResult.signature, keys: decryptionKeyImported });\n        expect(decryptionResult.every((s) => (s.valid || s.valid === undefined)), `failed at ${p}`).to.be.true;\n      }));\n    }));\n  });\n\n\n});",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.basic.sign.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 259,
    "kind": "test",
    "name": "describe31",
    "testId": 31,
    "memberof": "test/api.basic.sign.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.basic.sign.spec.js~describe31",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 260,
    "kind": "test",
    "name": "it32",
    "testId": 32,
    "memberof": "test/api.basic.sign.spec.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.sign.spec.js~describe31.it32",
    "access": null,
    "description": "jscu: EC/RSA signing test",
    "lineNumber": 25
  },
  {
    "__docId__": 261,
    "kind": "test",
    "name": "it33",
    "testId": 33,
    "memberof": "test/api.basic.sign.spec.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.sign.spec.js~describe31.it33",
    "access": null,
    "description": "openpgp: RSA/EC signing test",
    "lineNumber": 51
  },
  {
    "__docId__": 262,
    "kind": "test",
    "name": "it34",
    "testId": 34,
    "memberof": "test/api.basic.sign.spec.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.sign.spec.js~describe31.it34",
    "access": null,
    "description": "jscu: EC/RSA signing test with multiple secret keys",
    "lineNumber": 78
  },
  {
    "__docId__": 263,
    "kind": "test",
    "name": "it35",
    "testId": 35,
    "memberof": "test/api.basic.sign.spec.js~describe31",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.basic.sign.spec.js~describe31.it35",
    "access": null,
    "description": "openpgp: RSA/EC signing test with multiple secret keys",
    "lineNumber": 111
  },
  {
    "__docId__": 264,
    "kind": "testFile",
    "name": "test/api.cascade.encrypt-sign.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: cascaded single public key encryption/decryption with simultaneous signing/verification`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: EC/RSA encryption and signing mono-step procedure test with ECDH ephemeral keys',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutineEphemeral(message, param, []);\n  });\n\n  it('jscu: EC/RSA encryption and signing hybrid-step procedure test via session key encrypt with ECDH ephemeral keys',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutineEphemeral(message, param, [\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('jscu: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt with ECDH ephemeral keys',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutineEphemeral(message, param, [\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('jscu: EC/RSA encryption and signing mono-step procedure test',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutine(message, param, []);\n  });\n\n  it('jscu: EC/RSA encryption and signing hybrid-step procedure test via session key encrypt',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutine(message, param, [\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('jscu: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutine(message, param, [\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('openpgp: EC/RSA encryption and signing mono-step procedure test',  async function () {\n    this.timeout(50000);\n    await openpgpMainRoutine(message, param, []);\n  });\n\n  it('openpgp: EC/RSA encryption and signing hybrid-step procedure test via session key encrypt',  async function () {\n    this.timeout(50000);\n    await openpgpMainRoutine(message, param, [\n      { encrypt: param.openpgpOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('openpgp: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt',  async function () {\n    this.timeout(50000);\n    await openpgpMainRoutine(message, param, [\n      { encrypt: param.openpgpOnetimeSessionEncryptConf, sign: {required: true} },\n      { encrypt: param.openpgpOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('jscu: EC/RSA encryption and signing hybrid-step procedure test via public key encrypt',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutine(message, param, [\n      { encrypt: param.jscuOnetimePublicEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('jscu: EC/RSA encryption and signing hybrid-step procedure test via public key encrypt with ephemeralKeys',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutineEphemeral(message, param, [\n      { encrypt: param.jscuOnetimePublicEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('openpgp: EC/RSA encryption and signing hybrid-step procedure test via public key encrypt',  async function () {\n    this.timeout(50000);\n    await openpgpMainRoutine(message, param, [\n      { encrypt: param.openpgpOnetimePublicEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n});\n\nasync function jscuMainRoutineEphemeral(message, param, precedenceProcedure){\n  await Promise.all(param.paramArray.map(async (paramObject) => {\n    await Promise.all(paramObject.param.map(async (p, idx) => {\n\n      const encryptionKeys = {\n        publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString],\n        privateKeyPassSets: [{privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: ''}] // for Signing\n      };\n      const encryptionProcedure = precedenceProcedure.concat(\n        [{encrypt: param.jscuEncryptConfEphemeral(paramObject), sign: param.jscuSignConf(paramObject)}]\n      );\n\n      const encryptionKeyImported = await cascade.importKeys(\n        'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu' }, mode: ['encrypt', 'sign']}\n      );\n\n      const eProcess = await cascade.createEncryptionCascade({keys: encryptionKeyImported, procedure: encryptionProcedure});\n      const encrypted = await eProcess.encrypt(message);\n\n      const serialized = encrypted.serialize();\n      const deserialized = cascade.importCascadedBuffer(serialized);\n\n      const decryptionKeys = {\n        privateKeyPassSets: [{privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: ''}],\n        publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString], // for Signing\n      };\n      const decryptionKeyImported = await cascade.importKeys(\n        'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu' }, mode: ['decrypt', 'verify']}\n      );\n\n      const dProcess = await cascade.createDecryptionCascade({keys: decryptionKeyImported, encrypted: deserialized});\n      const decrypted = await dProcess.decrypt();\n      expect(decrypted[0].data.toString() === message.toString(), `failed at ${p}`).to.be.true;\n      expect(decrypted.every( (obj) => obj.signatures.every( (s) => s.valid)), `failed at ${p}`).to.be.true;\n\n    }));\n  }));\n}\n\nasync function jscuMainRoutine(message, param, precedenceProcedure){\n  await Promise.all(param.paramArray.map(async (paramObject) => {\n    await Promise.all(paramObject.param.map(async (p, idx) => {\n\n      const encryptionKeys = {\n        publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString],\n        privateKeyPassSets: [{privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: ''}] // for Signing\n      };\n      const encryptionProcedure = precedenceProcedure.concat(\n        [{encrypt: param.jscuEncryptConf(paramObject, idx), sign: param.jscuSignConf(paramObject)}]\n      );\n\n      const encryptionKeyImported = await cascade.importKeys(\n        'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu' }, mode: ['encrypt', 'sign']}\n      );\n\n      const eProcess = await cascade.createEncryptionCascade({keys: encryptionKeyImported, procedure: encryptionProcedure});\n      const encrypted = await eProcess.encrypt(message);\n\n      const serialized = encrypted.serialize();\n      const deserialized = cascade.importCascadedBuffer(serialized);\n\n      const decryptionKeys = {\n        privateKeyPassSets: [{privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: ''}],\n        publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString], // for Signing\n      };\n      const decryptionKeyImported = await cascade.importKeys(\n        'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu' }, mode: ['decrypt', 'verify']}\n      );\n\n      const dProcess = await cascade.createDecryptionCascade({keys: decryptionKeyImported, encrypted: deserialized});\n      const decrypted = await dProcess.decrypt();\n      expect(decrypted[0].data.toString() === message.toString(), `failed at ${p}`).to.be.true;\n      expect(decrypted.every( (obj) => obj.signatures.every( (s) => s.valid)), `failed at ${p}`).to.be.true;\n\n    }));\n  }));\n}\n\nasync function openpgpMainRoutine(message, param, precedenceProcedure){\n  await Promise.all(param.paramArray.map(async (paramObject) => {\n    await Promise.all(paramObject.param.map(async (p, idx) => {\n\n      const encryptionKeys = {\n        publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString],\n        privateKeyPassSets: [{privateKey: param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: ''}] // for Signing\n      };\n      const encryptionProcedure = precedenceProcedure.concat(\n        [{encrypt: param.openpgpEncryptConf, sign: param.openpgpSignConf}]\n      );\n\n      const encryptionKeyImported = await cascade.importKeys(\n        'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp' }, mode: ['encrypt', 'sign']}\n      );\n\n      const eProcess = await cascade.createEncryptionCascade({keys: encryptionKeyImported, procedure: encryptionProcedure});\n      const encrypted = await eProcess.encrypt(message);\n\n      const serialized = encrypted.serialize();\n      const deserialized = cascade.importCascadedBuffer(serialized);\n\n      const decryptionKeys = {\n        privateKeyPassSets: [{privateKey: param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: ''}],\n        publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString], // for Signing\n      };\n      const decryptionKeyImported = await cascade.importKeys(\n        'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp' }, mode: ['decrypt', 'verify']}\n      );\n\n      const dProcess = await cascade.createDecryptionCascade({keys: decryptionKeyImported, encrypted: deserialized});\n      const decrypted = await dProcess.decrypt();\n      expect(decrypted[0].data.toString() === message.toString(), `failed at ${p}`).to.be.true;\n      expect(decrypted.every( (obj) => obj.signatures.every( (s) => s.valid)), `failed at ${p}`).to.be.true;\n\n    }));\n  }));\n}",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.cascade.encrypt-sign.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 265,
    "kind": "test",
    "name": "describe36",
    "testId": 36,
    "memberof": "test/api.cascade.encrypt-sign.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 266,
    "kind": "test",
    "name": "it37",
    "testId": 37,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it37",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing mono-step procedure test with ECDH ephemeral keys",
    "lineNumber": 25
  },
  {
    "__docId__": 267,
    "kind": "test",
    "name": "it38",
    "testId": 38,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it38",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing hybrid-step procedure test via session key encrypt with ECDH ephemeral keys",
    "lineNumber": 30
  },
  {
    "__docId__": 268,
    "kind": "test",
    "name": "it39",
    "testId": 39,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it39",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt with ECDH ephemeral keys",
    "lineNumber": 37
  },
  {
    "__docId__": 269,
    "kind": "test",
    "name": "it40",
    "testId": 40,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it40",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing mono-step procedure test",
    "lineNumber": 45
  },
  {
    "__docId__": 270,
    "kind": "test",
    "name": "it41",
    "testId": 41,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it41",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing hybrid-step procedure test via session key encrypt",
    "lineNumber": 50
  },
  {
    "__docId__": 271,
    "kind": "test",
    "name": "it42",
    "testId": 42,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it42",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt",
    "lineNumber": 57
  },
  {
    "__docId__": 272,
    "kind": "test",
    "name": "it43",
    "testId": 43,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it43",
    "access": null,
    "description": "openpgp: EC/RSA encryption and signing mono-step procedure test",
    "lineNumber": 65
  },
  {
    "__docId__": 273,
    "kind": "test",
    "name": "it44",
    "testId": 44,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it44",
    "access": null,
    "description": "openpgp: EC/RSA encryption and signing hybrid-step procedure test via session key encrypt",
    "lineNumber": 70
  },
  {
    "__docId__": 274,
    "kind": "test",
    "name": "it45",
    "testId": 45,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it45",
    "access": null,
    "description": "openpgp: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt",
    "lineNumber": 77
  },
  {
    "__docId__": 275,
    "kind": "test",
    "name": "it46",
    "testId": 46,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it46",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing hybrid-step procedure test via public key encrypt",
    "lineNumber": 85
  },
  {
    "__docId__": 276,
    "kind": "test",
    "name": "it47",
    "testId": 47,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it47",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing hybrid-step procedure test via public key encrypt with ephemeralKeys",
    "lineNumber": 92
  },
  {
    "__docId__": 277,
    "kind": "test",
    "name": "it48",
    "testId": 48,
    "memberof": "test/api.cascade.encrypt-sign.spec.js~describe36",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.encrypt-sign.spec.js~describe36.it48",
    "access": null,
    "description": "openpgp: EC/RSA encryption and signing hybrid-step procedure test via public key encrypt",
    "lineNumber": 99
  },
  {
    "__docId__": 278,
    "kind": "testFile",
    "name": "test/api.cascade.extract-insert.spec.js",
    "content": "import {getTestEnv} from './prepare.js';\nconst testEnv = getTestEnv();\nconst cascade = testEnv.library;\nconst env = testEnv.envName;\n\nimport chai from 'chai';\n// const should = chai.should();\nconst expect = chai.expect;\n\nimport {createParam} from './params-basic.js';\n\ndescribe(`${env}: cascaded single public key encryption/decryption with encrypted data pop and simultaneous signing/verification`, () => {\n\n  let message;\n  let param;\n\n  before(async function () {\n    this.timeout(50000);\n    message = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) message[i] = 0xFF & i;\n\n    param = await createParam();\n  });\n\n  it('jscu: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt with ECDH ephemeral keys',  async function () {\n    this.timeout(50000);\n    await jscuMainRoutineEphemeral(message, param, [\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n      { encrypt: param.jscuOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n  it('openpgp: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt',  async function () {\n    this.timeout(50000);\n    await openpgpMainRoutine(message, param, [\n      { encrypt: param.openpgpOnetimeSessionEncryptConf, sign: {required: true} },\n      { encrypt: param.openpgpOnetimeSessionEncryptConf, sign: {required: true} },\n    ]);\n  });\n\n\n\n});\n\nasync function jscuMainRoutineEphemeral(message, param, precedenceProcedure){\n  await Promise.all(param.paramArray.map(async (paramObject) => {\n    await Promise.all(paramObject.param.map(async (p, idx) => {\n\n      const encryptionKeys = {\n        publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString],\n        privateKeyPassSets: [{privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: ''}] // for Signing\n      };\n      const encryptionProcedure = precedenceProcedure.concat(\n        [{encrypt: param.jscuEncryptConfEphemeral(paramObject), sign: param.jscuSignConf(paramObject)}]\n      );\n\n      const encryptionKeyImported = await cascade.importKeys(\n        'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu' }, mode: ['encrypt', 'sign']}\n      );\n\n      const eProcess = await cascade.createEncryptionCascade({keys: encryptionKeyImported, procedure: encryptionProcedure});\n      const encrypted = await eProcess.encrypt(message);\n\n      for(let n = 0; n < encrypted.length; n++) {\n        const extracted = encrypted.extract(n);\n        expect(encrypted[n].message.message.length === 0).to.be.true;\n\n        const serialized = encrypted.serialize();\n        const serializedExtracted = extracted.map( (obj) => obj.serialize() );\n\n        const deserialized = cascade.importCascadedBuffer(serialized);\n        const deserializedExtracted = cascade.importRawEncryptedBufferList(serializedExtracted);\n        encrypted.insert(n, extracted); // recover original encrypted message for next loop\n\n        deserialized.insert(n, deserializedExtracted);\n        expect(deserialized[n].message.message.length === extracted.length).to.be.true;\n        expect(deserializedExtracted.length === extracted.length).to.be.true;\n\n        const decryptionKeys = {\n          privateKeyPassSets: [{privateKey: param.Keys[paramObject.name][idx].privateKey.keyString, passphrase: ''}],\n          publicKeys: [param.Keys[paramObject.name][idx].publicKey.keyString], // for Signing\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'jscu', sign_verify: 'jscu' }, mode: ['decrypt', 'verify']}\n        );\n\n        const dProcess = await cascade.createDecryptionCascade({keys: decryptionKeyImported, encrypted: deserialized});\n        const decrypted = await dProcess.decrypt();\n        expect(decrypted[0].data.toString() === message.toString(), `failed at ${p}`).to.be.true;\n        expect(decrypted.every( (obj) => obj.signatures.every( (s) => s.valid)), `failed at ${p}`).to.be.true;\n      }\n\n    }));\n  }));\n}\n\n\nasync function openpgpMainRoutine(message, param, precedenceProcedure){\n  await Promise.all(param.paramArray.map(async (paramObject) => {\n    await Promise.all(paramObject.param.map(async (p, idx) => {\n\n      const encryptionKeys = {\n        publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString],\n        privateKeyPassSets: [{privateKey: param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: ''}] // for Signing\n      };\n      const encryptionProcedure = precedenceProcedure.concat(\n        [{encrypt: param.openpgpEncryptConf, sign: param.openpgpSignConf}]\n      );\n\n      const encryptionKeyImported = await cascade.importKeys(\n        'string', {keys: encryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp' }, mode: ['encrypt', 'sign']}\n      );\n\n      const eProcess = await cascade.createEncryptionCascade({keys: encryptionKeyImported, procedure: encryptionProcedure});\n      const encrypted = await eProcess.encrypt(message);\n\n      for(let n = 0; n < encrypted.length; n++) {\n        const extracted = encrypted.extract(n);\n        expect(encrypted[n].message.message.length === 0).to.be.true;\n\n        const serialized = encrypted.serialize();\n        const serializedExtracted = extracted.map( (obj) => obj.serialize() );\n\n        const deserialized = cascade.importCascadedBuffer(serialized);\n        const deserializedExtracted = cascade.importRawEncryptedBufferList(serializedExtracted);\n        encrypted.insert(n, extracted); // recover original encrypted message for next loop\n\n        deserialized.insert(n, deserializedExtracted);\n        expect(deserialized[n].message.message.length === extracted.length).to.be.true;\n        expect(deserializedExtracted.length === extracted.length).to.be.true;\n\n        const decryptionKeys = {\n          privateKeyPassSets: [{privateKey: param.KeysGPG[paramObject.name][idx].privateKey.keyString, passphrase: ''}],\n          publicKeys: [param.KeysGPG[paramObject.name][idx].publicKey.keyString], // for Signing\n        };\n        const decryptionKeyImported = await cascade.importKeys(\n          'string', {keys: decryptionKeys, suite: {encrypt_decrypt: 'openpgp', sign_verify: 'openpgp' }, mode: ['decrypt', 'verify']}\n        );\n\n        const dProcess = await cascade.createDecryptionCascade({keys: decryptionKeyImported, encrypted: deserialized});\n        const decrypted = await dProcess.decrypt();\n        expect(decrypted[0].data.toString() === message.toString(), `failed at ${p}`).to.be.true;\n        expect(decrypted.every( (obj) => obj.signatures.every( (s) => s.valid)), `failed at ${p}`).to.be.true;\n      }\n\n    }));\n  }));\n}\n",
    "static": true,
    "longname": "/Users/jun/ProjectJavaScript/cascade/test/api.cascade.extract-insert.spec.js",
    "access": null,
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 279,
    "kind": "test",
    "name": "describe49",
    "testId": 49,
    "memberof": "test/api.cascade.extract-insert.spec.js",
    "testDepth": 0,
    "static": true,
    "longname": "test/api.cascade.extract-insert.spec.js~describe49",
    "access": null,
    "lineNumber": 12
  },
  {
    "__docId__": 280,
    "kind": "test",
    "name": "it50",
    "testId": 50,
    "memberof": "test/api.cascade.extract-insert.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.extract-insert.spec.js~describe49.it50",
    "access": null,
    "description": "jscu: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt with ECDH ephemeral keys",
    "lineNumber": 25
  },
  {
    "__docId__": 281,
    "kind": "test",
    "name": "it51",
    "testId": 51,
    "memberof": "test/api.cascade.extract-insert.spec.js~describe49",
    "testDepth": 1,
    "static": true,
    "longname": "test/api.cascade.extract-insert.spec.js~describe49.it51",
    "access": null,
    "description": "openpgp: EC/RSA encryption and signing tribrid-step procedure test via session key encrypt",
    "lineNumber": 33
  }
]